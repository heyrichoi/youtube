<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>유튜브 크리에이터 프로 도구 모음</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        /* Google Fonts Import: Korean-supported bold and impactful fonts */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700;900&family=Roboto:wght@300;400;500;700;900&family=Black+Han+Sans&family=Do+Hyeon&family=Jua&family=Gothic+A1:wght@900&family=Sunflower:wght@700&family=Nanum+Gothic:wght@800&family=Nanum+Myeongjo:wght@800&family=Nanum+Pen+Script&display=swap');
        
        /* Universal Box-sizing */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Body Styles */
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: linear-gradient(135deg, #0f0f0f 0%, #1a1a2e 25%, #16213e 50%, #0f3460 75%, #533483 100%);
            color: #e5e5e7;
            min-height: 100vh;
            overflow-x: hidden;
            display: flex; /* Use flexbox for main layout to center content */
            justify-content: center;
            align-items: flex-start; /* Align items to the top */
            padding: 20px 0; /* Add vertical padding to body */
        }

        /* Main Container */
        .container {
            width: 100%;
            max-width: 1600px;
            padding: 20px;
            margin: 0 auto; /* Center the container */
        }

        /* Header Styles */
        .header {
            text-align: center;
            margin-bottom: 40px;
            position: relative;
        }

        .header h1 {
            font-size: 3.5rem;
            font-weight: 900;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57, #ff9ff3);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 4s ease-in-out infinite;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(255, 107, 107, 0.3);
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .header p {
            font-size: 1.3rem;
            opacity: 0.9;
            font-weight: 300;
            margin-bottom: 30px;
        }

        /* Tab Navigation */
        .tabs {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 30px;
        }

        .tab-btn {
            padding: 14px 28px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 30px;
            color: #e5e5e7;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(15px);
            font-size: 0.9rem;
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }

        .tab-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s;
        }

        .tab-btn:hover::before {
            left: 100%;
        }

        .tab-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
        }

        .tab-btn.active {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border-color: transparent;
            color: white;
            font-weight: 600;
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 107, 107, 0.4);
        }

        /* Tool Section General Styles */
        .tool-section {
            display: none;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 25px;
            padding: 40px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            animation: fadeIn 0.6s ease-in-out;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .tool-section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Tool Grid Layout */
        .tool-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-top: 25px;
        }

        /* Tool Card Styles */
        .tool-card {
            background: rgba(255, 255, 255, 0.06);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
        }

        .tool-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .tool-card:hover::before {
            opacity: 1;
        }

        .tool-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4);
            background: rgba(255, 255, 255, 0.08);
        }

        .tool-card h3 {
            font-size: 1.4rem;
            font-weight: 600;
            color: #4ecdc4;
            margin-bottom: 20px;
        }

        /* Input Group Styles */
        .input-group {
            margin-bottom: 18px;
        }

        .input-group label {
            display: block;
            font-size: 0.95rem;
            font-weight: 500;
            color: #4ecdc4;
            margin-bottom: 8px;
        }

        .input-group input, 
        .input-group textarea, 
        .input-group select {
            width: 100%;
            padding: 14px 16px;
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #e5e5e7;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        .input-group input:focus, 
        .input-group textarea:focus, 
        .input-group select:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 25px rgba(78, 205, 196, 0.3);
            background: rgba(255, 255, 255, 0.12);
        }

        /* Button Styles */
        .btn {
            padding: 14px 28px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            border-radius: 12px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.4);
            background: linear-gradient(45deg, #ff5252, #26a69a);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #667eea, #764ba2);
        }

        .btn-secondary:hover {
            background: linear-gradient(45deg, #5a67d8, #6b46c1);
        }

        /* Result Box Styles */
        .result-box {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border-left: 5px solid #4ecdc4;
            font-family: 'Roboto', monospace;
            line-height: 1.6;
            backdrop-filter: blur(10px);
        }

        /* Thumbnail Editor Specific Styles */
        .thumbnail-workspace {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }

        .canvas-container {
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .thumbnail-canvas {
            border: 3px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            background: white; /* Canvas default background */
            width: 100%;
            max-width: 1280px; /* Ensure it can take full width if container allows */
            height: auto;
            aspect-ratio: 16 / 9; /* Maintain 16:9 aspect ratio */
            cursor: crosshair;
            transition: all 0.3s ease;
            display: block; /* Remove extra space below canvas */
            margin: 0 auto; /* Center canvas within its container */
        }

        .thumbnail-canvas:hover {
            border-color: #ffd700;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.4);
        }

        .thumbnail-canvas.dragging {
            cursor: move;
        }

        .controls-panel {
            background: rgba(255, 255, 255, 0.06);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-height: 600px; /* Constrain height */
            overflow-y: auto; /* Enable scrolling for controls */
        }

        .controls-panel::-webkit-scrollbar {
            width: 6px;
        }

        .controls-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .controls-panel::-webkit-scrollbar-thumb {
            background: #4ecdc4;
            border-radius: 3px;
        }

        .control-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-section:last-child {
            border-bottom: none;
        }

        .control-section h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #ff6b6b;
            margin-bottom: 15px;
        }

        /* Font Selector Styles */
        .font-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); /* Responsive 3 columns */
            gap: 10px;
            margin-bottom: 15px;
        }

        .font-option {
            padding: 10px;
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .font-option:hover, .font-option.active {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.2);
        }
        .font-option.recommended {
            border-color: #feca57;
            box-shadow: 0 0 10px rgba(254, 202, 87, 0.5);
        }

        /* Font Style Template Grid */
        .font-style-template-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); /* Adjusted for more templates */
            gap: 10px;
            margin-top: 15px;
        }

        .font-style-template-item {
            padding: 12px 15px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            color: #e5e5e7;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            text-align: center;
            transition: all 0.3s ease;
        }

        .font-style-template-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        /* Color Palette Styles */
        .color-palette {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(40px, 1fr)); /* Responsive swatches */
            gap: 10px;
            margin: 15px 0;
        }

        .color-swatch {
            width: 100%;
            height: 40px;
            border-radius: 10px;
            cursor: pointer;
            border: 3px solid rgba(255, 255, 255, 0.2);
            position: relative;
            transition: all 0.3s ease;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            border-color: white;
        }

        .color-swatch.active::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }

        /* Slider Styles */
        .slider-container {
            margin: 15px 0;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
            appearance: none; /* Standard property */
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4ecdc4;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        /* Background Template Grid */
        .template-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); /* Responsive columns */
            gap: 15px;
            margin-top: 20px;
        }

        .template-item {
            aspect-ratio: 16/9;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .template-item:hover {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.2);
            transform: scale(1.05);
        }

        /* Subtitle Generator Specific Styles */
        .subtitle-editor {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }

        .subtitle-input {
            background: rgba(255, 255, 255, 0.06);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .subtitle-preview {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-height: 400px;
            overflow-y: auto;
        }

        .subtitle-item {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #4ecdc4;
            position: relative; /* For delete button positioning */
        }

        .subtitle-time {
            font-family: 'Roboto', monospace;
            color: #ff6b6b;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .subtitle-text {
            color: #e5e5e7;
            line-height: 1.5;
        }

        /* Tag Container Styles */
        .tag-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .tag {
            background: linear-gradient(45deg, #667eea, #764ba2);
            padding: 8px 16px;
            border-radius: 25px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tag:hover {
            transform: scale(1.08);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        /* Schedule Item Styles */
        .schedule-item {
            background: rgba(255, 255, 255, 0.06);
            padding: 20px;
            border-radius: 12px;
            margin: 15px 0;
            border-left: 5px solid #ff6b6b;
            transition: all 0.3s ease;
        }

        .schedule-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(5px);
        }

        /* Analytics Chart Placeholder */
        .analytics-chart {
            height: 250px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-style: italic;
            opacity: 0.8;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center; /* Center text within the chart */
            padding: 20px; /* Add padding for readability */
        }

        /* Trend Item Styles */
        .trend-item {
            background: rgba(255, 255, 255, 0.06);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            border-left: 4px solid #4ecdc4;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .trend-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(5px);
        }

        /* Progress Bar (if used) */
        .progress-bar {
            width: 100%;
            height: 25px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            margin: 15px 0;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #45b7d1);
            border-radius: 12px;
            transition: width 0.5s ease;
            position: relative;
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            font-size: 12px;
        }

        /* Responsive Adjustments */
        @media (max-width: 1024px) {
            .thumbnail-workspace, 
            .subtitle-editor {
                grid-template-columns: 1fr; /* Stack columns on smaller screens */
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2.5rem;
            }
            
            .tool-grid {
                grid-template-columns: 1fr;
            }
            
            .tabs {
                flex-direction: column;
                align-items: center;
            }
            
            .container {
                padding: 15px;
            }

            .tool-section {
                padding: 20px;
            }
        }

        /* Notification Styles */
        @keyframes slideInNotification {
            from { opacity: 0; transform: translateX(100px); }
            to { opacity: 1; transform: translateX(0); }
        }
        @keyframes slideOutNotification {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(100px); }
        }
        .confirmed-text-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 5px;
            cursor: pointer;
            transition: background 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .confirmed-text-item:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        .confirmed-text-item.selected {
            border: 2px solid #ffd700;
            background: rgba(255, 215, 0, 0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>⚔️ 로스트아크 유튜버 전용 도구 🏰</h1>
            <p>로스트아크 콘텐츠 제작을 위한 전문가급 썸네일 & 영상 제작 도구</p>
        </div>

        <div class="tabs">
            <div class="tab-btn active" onclick="showTab(event, 'thumbnail')"><i class="fas fa-magic"></i> 로스트아크 썸네일</div>
            <div class="tab-btn" onclick="showTab(event, 'subtitle')"><i class="fas fa-closed-captioning"></i> 자막 생성기</div>
            <div class="tab-btn" onclick="showTab(event, 'title')"><i class="fas fa-edit"></i> 제목 최적화</div>
            <div class="tab-btn" onclick="showTab(event, 'tags')"><i class="fas fa-hashtag"></i> 태그 & 해시태그</div>
            <div class="tab-btn" onclick="showTab(event, 'schedule')"><i class="fas fa-calendar-alt"></i> 스케줄 관리</div>
            <div class="tab-btn" onclick="showTab(event, 'analytics')"><i class="fas fa-chart-line"></i> 분석 & 예측</div>
            <div class="tab-btn" onclick="showTab(event, 'keyword')"><i class="fas fa-search"></i> 키워드 & 트렌드</div>
            <div class="tab-btn" onclick="showTab(event, 'community')"><i class="fas fa-users"></i> 커뮤니티 도구</div>
        </div>

        <!-- 로스트아크 특화 썸네일 제작 도구 -->
        <div id="thumbnail" class="tool-section active">
            <h2><i class="fas fa-image"></i> 로스트아크 특화 썸네일 제작 도구</h2>
            <div class="thumbnail-workspace">
                <div class="canvas-container">
                    <canvas id="thumbnailCanvas" class="thumbnail-canvas" width="1280" height="720"></canvas>
                    <div style="margin-top: 15px; text-align: center;">
                        <button class="btn" onclick="downloadThumbnail()"><i class="fas fa-download"></i> 썸네일 다운로드</button>
                        <button class="btn btn-secondary" onclick="clearCanvas()"><i class="fas fa-trash"></i> 캔버스 초기화</button>
                        <button class="btn btn-secondary" onclick="deleteSelectedText()"><i class="fas fa-backspace"></i> 선택 텍스트 삭제</button>
                        <button class="btn btn-secondary" onclick="undoCanvas()"><i class="fas fa-undo"></i> 뒤로가기</button>
                        <button class="btn btn-secondary" onclick="redoCanvas()"><i class="fas fa-redo"></i> 다시 실행</button>
                    </div>
                    <div style="margin-top: 10px; text-align: center; opacity: 0.7; font-size: 12px;">
                        💡 텍스트를 클릭하여 선택 후, 아래 버튼으로 위치를 조정하거나 삭제하세요.
                    </div>
                    <div class="confirmed-text-list" id="confirmedTextList" style="margin-top: 20px; max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 10px; padding: 10px;">
                        <p style="opacity: 0.7; text-align: center;">확정된 텍스트가 없습니다.</p>
                    </div>
                </div>
                
                <div class="controls-panel">
                    <div class="control-section">
                        <h4><i class="fas fa-image"></i> 로스트아크 배경 템플릿</h4>
                        <input type="file" id="backgroundImage" accept="image/*" onchange="loadBackgroundImage()" style="margin-bottom: 15px;">
                        <div class="template-grid">
                            <div class="template-item" onclick="loadTemplate('lostark_dark')" style="background: linear-gradient(45deg, #1a1a2e, #16213e);">⚔️ 다크</div>
                            <div class="template-item" onclick="loadTemplate('lostark_gold')" style="background: linear-gradient(45deg, #ffd700, #ff8c00);">� 골드</div>
                            <div class="template-item" onclick="loadTemplate('lostark_fire')" style="background: linear-gradient(45deg, #ff4500, #dc143c);">🔥 파이어</div>
                            <div class="template-item" onclick="loadTemplate('lostark_ice')" style="background: linear-gradient(45deg, #4169e1, #00bfff);">❄️ 아이스</div>
                            <div class="template-item" onclick="loadTemplate('lostark_nature')" style="background: linear-gradient(45deg, #228b22, #32cd32);">🌿 네이처</div>
                            <div class="template-item" onclick="loadTemplate('lostark_purple')" style="background: linear-gradient(45deg, #8a2be2, #9932cc);">💜 퍼플</div>
                        </div>
                        <div style="margin-top: 15px; text-align: center;">
                            <button class="btn btn-secondary" onclick="removeBackgroundTemplate()"><i class="fas fa-eraser"></i> 배경 템플릿 제거</button>
                        </div>
                        <div class="input-group" style="margin-top: 20px;">
                            <label>배경 색감 오버레이</label>
                            <input type="color" id="backgroundOverlayColor" value="#000000" oninput="updateBackgroundOverlay()">
                        </div>
                        <div class="slider-container">
                            <label>배경 오버레이 불투명도: <span id="backgroundOverlayOpacityValue">0</span>%</label>
                            <input type="range" id="backgroundOverlayOpacity" class="slider" min="0" max="100" value="0" oninput="updateBackgroundOverlay()">
                        </div>
                        <div class="slider-container">
                            <label>배경 이미지 X 위치: <span id="bgImageXValue">0</span>px</label>
                            <input type="range" id="bgImageX" class="slider" min="-1280" max="1280" value="0" oninput="updateBackgroundImagePosition()">
                        </div>
                        <div class="slider-container">
                            <label>배경 이미지 Y 위치: <span id="bgImageYValue">0</span>px</label>
                            <input type="range" id="bgImageY" class="slider" min="-720" max="720" value="0" oninput="updateBackgroundImagePosition()">
                        </div>
                        <div class="slider-container">
                            <label>배경 이미지 너비: <span id="bgImageWidthValue">1280</span>px</label>
                            <input type="range" id="bgImageWidth" class="slider" min="100" max="2560" value="1280" oninput="updateBackgroundImagePosition()">
                        </div>
                        <div class="slider-container">
                            <label>배경 이미지 높이: <span id="bgImageHeightValue">720</span>px</label>
                            <input type="range" id="bgImageHeight" class="slider" min="100" max="1440" value="720" oninput="updateBackgroundImagePosition()">
                        </div>
                    </div>

                    <div class="control-section">
                        <h4><i class="fas fa-font"></i> 실시간 텍스트 편집</h4>
                        <div class="input-group">
                            <input type="text" id="thumbnailText" placeholder="텍스트 입력" oninput="updatePreviewText()">
                        </div>
                        
                        <div style="margin: 15px 0;">
                            <h5 style="color: #ffd700; margin-bottom: 10px;">게임 특화 폰트</h5>
                            <div class="font-selector">
                                <div class="font-option active" data-font="Noto Sans KR" onclick="selectFont(this)" style="font-family: 'Noto Sans KR';">Noto Sans KR</div>
                                <div class="font-option" data-font="Roboto" onclick="selectFont(this)" style="font-family: 'Roboto';">Roboto</div>
                                <div class="font-option recommended" data-font="Black Han Sans" onclick="selectFont(this)" style="font-family: 'Black Han Sans';">Black Han Sans</div>
                                <div class="font-option recommended" data-font="Do Hyeon" onclick="selectFont(this)" style="font-family: 'Do Hyeon';">Do Hyeon</div>
                                <div class="font-option" data-font="Jua" onclick="selectFont(this)" style="font-family: 'Jua';">Jua</div>
                                <div class="font-option" data-font="Gothic A1" onclick="selectFont(this)" style="font-family: 'Gothic A1';">Gothic A1</div>
                                <div class="font-option" data-font="Sunflower" onclick="selectFont(this)" style="font-family: 'Sunflower';">Sunflower</div>
                                <div class="font-option" data-font="Nanum Gothic" onclick="selectFont(this)" style="font-family: 'Nanum Gothic';">Nanum Gothic</div>
                                <div class="font-option" data-font="Nanum Myeongjo" onclick="selectFont(this)" style="font-family: 'Nanum Myeongjo';">Nanum Myeongjo</div>
                                <div class="font-option" data-font="Nanum Pen Script" onclick="selectFont(this)" style="font-family: 'Nanum Pen Script';">Nanum Pen Script</div>
                            </div>
                        </div>

                        <div style="margin: 15px 0;">
                            <h5 style="color: #ffd700; margin-bottom: 10px;">폰트 스타일 템플릿</h5>
                            <div class="font-style-template-grid">
                                <button class="font-style-template-item" onclick="applyFontTemplate('modernBold')">모던 볼드</button>
                                <button class="font-style-template-item" onclick="applyFontTemplate('classicSerif')">클래식 세리프</button>
                                <button class="font-style-template-item" onclick="applyFontTemplate('handwrittenFun')">손글씨</button>
                                <button class="font-style-template-item" onclick="applyFontTemplate('impactfulHeadline')">임팩트 헤드라인</button>
                                <button class="font-style-template-item" onclick="applyFontTemplate('futuristicTech')">미래지향</button>
                                <!-- New Clean Templates -->
                                <button class="font-style-template-item" onclick="applyFontTemplate('boldOutlineYellow')">볼드 외곽선 (노랑)</button>
                                <button class="font-style-template-item" onclick="applyFontTemplate('boldOutlinePinkOrange')">볼드 외곽선 (핑크)</button>
                                <button class="font-style-template-item" onclick="applyFontTemplate('minimalistSans')">미니멀리스트</button>
                                <button class="font-style-template-item" onclick="applyFontTemplate('elegantThin')">엘레강스 씬</button>
                                <button class="font-style-template-item" onclick="applyFontTemplate('retroBlock')">레트로 블록</button>
                            </div>
                        </div>

                        <div style="margin: 15px 0;">
                            <h5 style="color: #ffd700; margin-bottom: 10px;">로스트아크 전용 템플릿 스타일</h5>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                <button class="btn btn-secondary" onclick="applyTextTemplate('legendary')" style="background: linear-gradient(45deg, #ffd700, #ff8c00);">전설 스타일</button>
                                <button class="btn btn-secondary" onclick="applyTextTemplate('epic')" style="background: linear-gradient(45deg, #9932cc, #8a2be2);">서사 스타일</button>
                                <button class="btn btn-secondary" onclick="applyTextTemplate('rare')" style="background: linear-gradient(45deg, #4169e1, #1e90ff);">희귀 스타일</button>
                                <button class="btn btn-secondary" onclick="applyTextTemplate('fire')" style="background: linear-gradient(45deg, #ff4500, #dc143c);">화염 스타일</button>
                            </div>
                        </div>

                        <div class="slider-container">
                            <label>글자 크기: <span id="fontSizeValue">80</span>px</label>
                            <input type="range" id="fontSize" class="slider" min="24" max="160" value="80" oninput="updateFontSize()">
                        </div>

                        <div class="slider-container">
                            <label>기울기: <span id="skewValue">0</span>°</label>
                            <input type="range" id="skewAngle" class="slider" min="-30" max="30" value="0" oninput="updateSkew()">
                        </div>

                        <div class="slider-container">
                            <label>X 위치: <span id="positionXValue">640</span>px</label>
                            <input type="range" id="positionX" class="slider" min="0" max="1280" value="640" oninput="updatePositionX()">
                        </div>
                        <div class="slider-container">
                            <label>Y 위치: <span id="positionYValue">360</span>px</label>
                            <input type="range" id="positionY" class="slider" min="0" max="720" value="360" oninput="updatePositionY()">
                        </div>

                        <div style="margin: 15px 0;">
                            <h5 style="color: #ffd700; margin-bottom: 10px;">텍스트 위치 조정</h5>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                                <button class="btn btn-secondary" onclick="positionText('topLeft')">좌측 상단</button>
                                <button class="btn btn-secondary" onclick="positionText('topCenter')">상단 중앙</button>
                                <button class="btn btn-secondary" onclick="positionText('topRight')">우측 상단</button>
                                <button class="btn btn-secondary" onclick="positionText('middleLeft')">좌측 중앙</button>
                                <button class="btn btn-secondary" onclick="positionText('center')">중앙</button>
                                <button class="btn btn-secondary" onclick="positionText('middleRight')">우측 중앙</button>
                                <button class="btn btn-secondary" onclick="positionText('bottomLeft')">좌측 하단</button>
                                <button class="btn btn-secondary" onclick="positionText('bottomCenter')">하단 중앙</button>
                                <button class="btn btn-secondary" onclick="positionText('bottomRight')">우측 하단</button>
                            </div>
                        </div>

                        <button class="btn" onclick="confirmText()" style="background: linear-gradient(45deg, #ffd700, #ff8c00); font-size: 16px; padding: 16px 32px;">
                            <i class="fas fa-check"></i> 텍스트 확정
                        </button>
                    </div>

                    <div class="control-section">
                        <h4><i class="fas fa-palette"></i> 로스트아크 색상 & 고급 효과</h4>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 8px;">텍스트 색상</label>
                            <div class="color-palette" id="colorPalette"></div>
                            <input type="color" id="customColor" onchange="updateSelectedColor()" style="width: 100%; margin-top: 8px;">
                        </div>

                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 8px;">외곽선 색상</label>
                            <div class="color-palette" id="strokeColorPalette"></div>
                            <input type="color" id="strokeColor" value="#000000" onchange="updateStrokeColor()" style="width: 100%; margin-top: 8px;">
                        </div>

                        <div class="slider-container">
                            <label>외곽선 두께: <span id="strokeWidthValue">5</span>px</label>
                            <input type="range" id="strokeWidth" class="slider" min="0" max="15" value="5" oninput="updateStrokeWidth()">
                        </div>

                        <div class="slider-container">
                            <label>그림자 흐림: <span id="shadowBlurValue">8</span>px</label>
                            <input type="range" id="shadowBlur" class="slider" min="0" max="25" value="8" oninput="updateShadowBlur()">
                        </div>

                        <div class="slider-container">
                            <label>그림자 거리: <span id="shadowDistanceValue">4</span>px</label>
                            <input type="range" id="shadowDistance" class="slider" min="0" max="20" value="4" oninput="updateShadowDistance()">
                        </div>

                        <div style="margin: 15px 0;">
                            <label style="display: block; margin-bottom: 8px;">글로우 효과</label>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                <button class="btn btn-secondary" onclick="applyGlowEffect('gold')" style="background: linear-gradient(45deg, #ffd700, #ffb347);">골드 글로우</button>
                                <button class="btn btn-secondary" onclick="applyGlowEffect('blue')" style="background: linear-gradient(45deg, #4169e1, #87ceeb);">블루 글로우</button>
                                <button class="btn btn-secondary" onclick="applyGlowEffect('red')" style="background: linear-gradient(45deg, #ff4500, #ff6347);">레드 글로우</button>
                                <button class="btn btn-secondary" onclick="applyGlowEffect('purple')" style="background: linear-gradient(45deg, #9932cc, #da70d6);">퍼플 글로우</button>
                            </div>
                        </div>
                    </div>

                    <div class="control-section">
                        <h4><i class="fas fa-magic"></i> 로스트아크 전용 텍스트 생성</h4>
                        <div style="display: grid; grid-template-columns: 1fr; gap: 8px;">
                            <button class="btn btn-secondary" onclick="generateLostArkText('raid')" style="font-size: 12px;">🏰 레이드 제목 생성</button>
                            <button class="btn btn-secondary" onclick="generateLostArkText('tier')" style="font-size: 12px;">⭐ 티어 업 제목 생성</button>
                            <button class="btn btn-secondary" onclick="generateLostArkText('pvp')" style="font-size: 12px;">⚔️ PvP 제목 생성</button>
                            <button class="btn btn-secondary" onclick="generateLostArkText('guide')" style="font-size: 12px;">📚 가이드 제목 생성</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 자막 생성기 -->
        <div id="subtitle" class="tool-section">
            <h2><i class="fas fa-closed-captioning"></i> 전문 자막 생성기</h2>
            <div class="subtitle-editor">
                <div class="subtitle-input">
                    <h3>자막 입력</h3>
                    <div class="input-group">
                        <label>시작 시간 (초)</label>
                        <input type="number" id="startTime" placeholder="0" step="0.1" min="0">
                    </div>
                    <div class="input-group">
                        <label>종료 시간 (초)</label>
                        <input type="number" id="endTime" placeholder="5" step="0.1" min="0">
                    </div>
                    <div class="input-group">
                        <label>자막 텍스트</label>
                        <textarea id="subtitleTextInput" rows="3" placeholder="자막 내용을 입력하세요"></textarea>
                    </div>
                    
                    <div style="margin-top: 30px;">
                        <h4>자막 스타일</h4>
                        <div class="input-group">
                            <label>글꼴</label>
                            <select id="subtitleFont">
                                <option value="Noto Sans KR">Noto Sans KR (기본)</option>
                                <option value="Roboto">Roboto</option>
                                <option value="Black Han Sans">Black Han Sans</option>
                                <option value="Do Hyeon">Do Hyeon</option>
                                <option value="Jua">Jua</option>
                                <option value="Gothic A1">Gothic A1</option>
                                <option value="Sunflower">Sunflower</option>
                                <option value="Nanum Gothic">Nanum Gothic</option>
                                <option value="Nanum Myeongjo">Nanum Myeongjo</option>
                                <option value="Nanum Pen Script">Nanum Pen Script</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label>글꼴 크기</label>
                            <select id="subtitleFontSize">
                                <option value="16">작게 (16px)</option>
                                <option value="20" selected>보통 (20px)</option>
                                <option value="24">크게 (24px)</option>
                                <option value="28">매우 크게 (28px)</option>
                                <option value="32">아주 크게 (32px)</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label>위치</label>
                            <select id="subtitlePosition">
                                <option value="bottom">하단</option>
                                <option value="top">상단</option>
                                <option value="middle">중앙</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label>텍스트 색상</label>
                            <input type="color" id="subtitleTextColor" value="#FFFFFF">
                        </div>
                        <div class="input-group">
                            <label>배경 색상</label>
                            <input type="color" id="subtitleBgColor" value="#000000">
                        </div>
                        <div class="slider-container">
                            <label>배경 불투명도: <span id="subtitleBgOpacityValue">70</span>%</label>
                            <input type="range" id="subtitleBgOpacity" class="slider" min="0" max="100" value="70">
                        </div>
                    </div>

                    <button class="btn" onclick="addSubtitle()"><i class="fas fa-plus"></i> 자막 추가</button>
                    
                    <div style="margin-top: 20px;">
                        <h4>SRT 파일 업로드</h4>
                        <input type="file" id="srtUpload" accept=".srt" onchange="loadSrtFile()" style="margin-bottom: 15px;">
                    </div>

                    <div style="margin-top: 20px;">
                        <button class="btn btn-secondary" onclick="exportSubtitles('srt')"><i class="fas fa-file-alt"></i> SRT 다운로드</button>
                        <button class="btn btn-secondary" onclick="exportSubtitles('vtt')"><i class="fas fa-file-code"></i> VTT 다운로드</button>
                    </div>
                </div>
                
                <div class="subtitle-preview">
                    <h3>자막 미리보기</h3>
                    <div id="subtitleList"></div>
                    <p style="opacity: 0.7; font-size: 0.8em; margin-top: 15px;">
                        💡 자막 스타일은 SRT 파일에 직접 포함되지 않으며, 이 도구에서 시각적 미리보기 및 관리를 위한 것입니다.
                    </p>
                </div>
            </div>
        </div>

        <!-- 제목 최적화 도구 -->
        <div id="title" class="tool-section">
            <h2><i class="fas fa-edit"></i> 제목 최적화 도구</h2>
            <div class="tool-grid">
                <div class="tool-card">
                    <h3>AI 제목 생성기</h3>
                    <div class="input-group">
                        <label>주요 키워드</label>
                        <input type="text" id="titleKeyword" placeholder="예: 요리, 게임, 리뷰">
                    </div>
                    <div class="input-group">
                        <label>영상 카테고리</label>
                        <select id="titleCategory">
                            <option value="how-to">하우투/튜토리얼</option>
                            <option value="review">리뷰</option>
                            <option value="vlog">브이로그</option>
                            <option value="gaming">게임</option>
                            <option value="music">음악</option>
                            <option value="comedy">코미디</option>
                            <option value="news">뉴스/정보</option>
                            <option value="unboxing">언박싱</option>
                            <option value="challenge">챌린지</</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>감정 톤</label>
                        <select id="emotionTone">
                            <option value="exciting">흥미진진한</option>
                            <option value="shocking">충격적인</option>
                            <option value="funny">재미있는</option>
                            <option value="informative">정보적인</option>
                            <option value="mysterious">신비로운</option>
                        </select>
                    </div>
                    <button class="btn" onclick="generateAdvancedTitles()"><i class="fas fa-magic"></i> 고급 제목 생성</button>
                    <div id="titleResults" class="result-box" style="display: none;"></div>
                </div>
                
                <div class="tool-card">
                    <h3>제목 성능 분석기</h3>
                    <div class="input-group">
                        <label>제목 입력</label>
                        <textarea id="titleAnalysis" placeholder="분석할 제목을 입력하세요" rows="3"></textarea>
                    </div>
                    <button class="btn" onclick="analyzeAdvancedTitle()"><i class="fas fa-search"></i> 상세 분석</button>
                    <div id="analysisResults" class="result-box" style="display: none;"></div>
                </div>
            </div>
        </div>

        <!-- 태그 & 해시태그 도구 -->
        <div id="tags" class="tool-section">
            <h2><i class="fas fa-hashtag"></i> 태그 & 해시태그 최적화</h2>
            <div class="tool-grid">
                <div class="tool-card">
                    <h3>스마트 태그 생성기</h3>
                    <div class="input-group">
                        <label>영상 주제</label>
                        <input type="text" id="tagTopic" placeholder="영상의 주제나 키워드 입력">
                    </div>
                    <div class="input-group">
                        <label>타겟 언어</label>
                        <select id="tagLanguage">
                            <option value="ko">한국어</option>
                            <option value="en">영어</option>
                            <option value="both">한국어 + 영어</option>
                        </select>
                    </div>
                    <button class="btn" onclick="generateSmartTags()"><i class="fas fa-tags"></i> 스마트 태그 생성</button>
                    <div id="tagResults" class="tag-container"></div>
                </div>
                
                <div class="tool-card">
                    <h3>해시태그 트렌드</h3>
                    <div class="input-group">
                        <label>카테고리 선택</label>
                        <select id="hashtagCategory">
                            <option value="general">일반</option>
                            <option value="gaming">게임</option>
                            <option value="beauty">뷰티</option>
                            <option value="food">음식</option>
                            <option value="tech">기술</option>
                            <option value="lifestyle">라이프스타일</option>
                        </select>
                    </div>
                    <button class="btn" onclick="generateTrendingHashtags()"><i class="fas fa-fire"></i> 트렌딩 해시태그</button>
                    <div id="hashtagResults" class="tag-container"></div>
                </div>
            </div>
            <div class="result-box">
                <strong>💡 태그 최적화 고급 팁:</strong><br>
                • 10-15개의 관련 태그 사용 (너무 많으면 스팸으로 인식)<br>
                • 브랜드명, 시리즈명 포함으로 브랜딩 강화<br>
                • 긴 키워드(3-4단어)와 짧은 키워드(1-2단어) 조합<br>
                • 경쟁이 낮은 롱테일 키워드 적극 활용<br>
                • 트렌딩 태그와 상시 태그의 균형 유지
            </div>
        </div>

        <!-- 스케줄 관리 도구 -->
        <div id="schedule" class="tool-section">
            <h2><i class="fas fa-calendar-alt"></i> 고급 스케줄 관리</h2>
            <div class="tool-grid">
                <div class="tool-card">
                    <h3>스케줄 추가</h3>
                    <div class="input-group">
                        <label>영상 제목</label>
                        <input type="text" id="scheduleTitle" placeholder="업로드할 영상 제목">
                    </div>
                    <div class="input-group">
                        <label>업로드 날짜 & 시간</label>
                        <input type="datetime-local" id="scheduleDate">
                    </div>
                    <div class="input-group">
                        <label>카테고리</label>
                        <select id="scheduleCategory">
                            <option value="일반">일반 콘텐츠</option>
                            <option value="시리즈">시리즈</option>
                            <option value="특별기획">특별기획</option>
                            <option value="라이브">라이브 스트림</option>
                            <option value="쇼츠">유튜브 쇼츠</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>우선순위</label>
                        <select id="schedulePriority">
                            <option value="high">높음 🔴</option>
                            <option value="medium" selected>보통 🟡</option>
                            <option value="low">낮음 🟢</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>메모</label>
                        <textarea id="scheduleNotes" rows="2" placeholder="추가 메모사항"></textarea>
                    </div>
                    <button class="btn" onclick="addAdvancedSchedule()"><i class="fas fa-plus"></i> 스케줄 추가</button>
                </div>
                
                <div class="tool-card">
                    <h3>업로드 캘린더</h3>
                    <div id="scheduleList"></div>
                    <div style="margin-top: 20px;">
                        <button class="btn btn-secondary" onclick="exportSchedule()"><i class="fas fa-file-export"></i> 스케줄 내보내기</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- 분석 & 예측 도구 -->
        <div id="analytics" class="tool-section">
            <h2><i class="fas fa-chart-line"></i> 고급 분석 & 예측 도구</h2>
            <div class="tool-grid">
                <div class="tool-card">
                    <h3>조회수 예측 AI</h3>
                    <div class="input-group">
                        <label>최근 10개 영상 평균 조회수</label>
                        <input type="number" id="avgViews" placeholder="예: 15000">
                    </div>
                    <div class="input-group">
                        <label>현재 구독자 수</label>
                        <input type="number" id="subscribers" placeholder="예: 50000">
                    </div>
                    <div class="input-group">
                        <label>영상 길이 (분)</label>
                        <input type="number" id="videoLength" placeholder="예: 10" min="1">
                    </div>
                    <div class="input-group">
                        <label>업로드 예정 시간</label>
                        <select id="uploadTime">
                            <option value="morning">오전 (9-12시)</option>
                            <option value="afternoon">오후 (12-18시)</option>
                            <option value="evening" selected>저녁 (18-22시)</option>
                            <option value="night">밤 (22-24시)</option>
                        </select>
                    </div>
                    <button class="btn" onclick="predictAdvancedViews()"><i class="fas fa-crystal-ball"></i> AI 예측 분석</button>
                    <div id="viewPrediction" class="result-box" style="display: none;"></div>
                </div>
                
                <div class="tool-card">
                    <h3>채널 성장 분석</h3>
                    <div class="analytics-chart">
                        <div style="text-align: center;">
                            📊 <strong>채널 성장 최적화 가이드</strong><br><br>
                            <strong>황금 업로드 시간대:</strong><br>
                            • 평일: 오후 7-9시 (직장인 타겟)<br>
                            • 주말: 오후 2-4시 (여유시간 활용)<br>
                            • 학생 타겟: 오후 4-6시<br><br>
                            <strong>최적 업로드 주기:</strong><br>
                            • 일관성이 핵심 (매주 같은 요일/시간)<br>
                            • 주 2-3회가 가장 효과적<br>
                            • 품질 > 양 (무리한 업로드 금지)
                        </div>
                    </div>
                    <button class="btn btn-secondary" onclick="analyzeChannelGrowth()"><i class="fas fa-chart-area"></i> 성장 패턴 분석</button>
                </div>
            </div>
        </div>

        <!-- 키워드 & 트렌드 연구 -->
        <div id="keyword" class="tool-section">
            <h2><i class="fas fa-search"></i> 키워드 & 트렌드 연구</h2>
            <div class="tool-grid">
                <div class="tool-card">
                    <h3>고급 키워드 분석</h3>
                    <div class="input-group">
                        <label>기본 키워드</label>
                        <input type="text" id="baseKeyword" placeholder="연구할 기본 키워드 입력">
                    </div>
                    <div class="input-group">
                        <label>경쟁 난이도</label>
                        <select id="competitionLevel">
                            <option value="low">낮음 (틈새 시장)</option>
                            <option value="medium" selected>보통 (균형잡힌)</option>
                            <option value="high">높음 (대중적)</option>
                        </select>
                    </div>
                    <button class="btn" onclick="researchAdvancedKeywords()"><i class="fas fa-microscope"></i> 고급 키워드 분석</button>
                    <div id="keywordResults" class="result-box" style="display: none;"></div>
                </div>
                
                <div class="tool-card">
                    <h3>실시간 트렌드 분석</h3>
                    <div class="input-group">
                        <label>트렌드 카테고리</label>
                        <select id="trendCategory">
                            <option value="all">전체</option>
                            <option value="gaming">게임</option>
                            <option value="entertainment">엔터테인먼트</option>
                            <option value="tech">기술</option>
                            <option value="lifestyle">라이프스타일</option>
                            <option value="news">뉴스</option>
                        </select>
                    </div>
                    <button class="btn" onclick="analyzeTrends()"><i class="fas fa-fire"></i> 트렌드 분석</button>
                    <div id="trendResults"></div>
                </div>
            </div>
            <div class="result-box">
                <strong>💡 태그 최적화 고급 팁:</strong><br>
                • 10-15개의 관련 태그 사용 (너무 많으면 스팸으로 인식)<br>
                • 브랜드명, 시리즈명 포함으로 브랜딩 강화<br>
                • 긴 키워드(3-4단어)와 짧은 키워드(1-2단어) 조합<br>
                • 경쟁이 낮은 롱테일 키워드 적극 활용<br>
                • 트렌딩 태그와 상시 태그의 균형 유지
            </div>
        </div>

        <!-- 커뮤니티 도구 -->
        <div id="community" class="tool-section">
            <h2><i class="fas fa-users"></i> 커뮤니티 관리 도구</h2>
            <div class="tool-grid">
                <div class="tool-card">
                    <h3>댓글 템플릿 생성기</h3>
                    <div class="input-group">
                        <label>댓글 타입</label>
                        <select id="commentType">
                            <option value="thanks">감사 인사</option>
                            <option value="question">질문 답변</</option>
                            <option value="engagement">참여 유도</option>
                            <option value="collaboration">협업 제안</option>
                            <option value="announcement">공지사항</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>톤 앤 매너</label>
                        <select id="commentTone">
                            <option value="friendly">친근한</option>
                            <option value="professional">전문적인</option>
                            <option value="casual">캐주얼한</option>
                            <option value="enthusiastic">열정적인</option>
                        </select>
                    </div>
                    <button class="btn" onclick="generateCommentTemplates()"><i class="fas fa-comments"></i> 댓글 템플릿 생성</button>
                    <div id="commentResults" class="result-box" style="display: none;"></div>
                </div>
                
                <div class="tool-card">
                    <h3>커뮤니티 포스트 생성기</h3>
                    <div class="input-group">
                        <label>포스트 주제</label>
                        <input type="text" id="postTopic" placeholder="커뮤니티 포스트 주제">
                    </div>
                    <div class="input-group">
                        <label>포스트 타입</label>
                        <select id="postType">
                            <option value="poll">투표</option>
                            <option value="question">질문</option>
                            <option value="announcement">공지</option>
                            <option value="behind">비하인드</option>
                            <option value="teaser">티저</option>
                        </select>
                    </div>
                    <button class="btn" onclick="generateCommunityPost()"><i class="fas fa-bullhorn"></i> 포스트 생성</button>
                    <div id="postResults" class="result-box" style="display: none;"></div>
                </div>
                
                <div class="tool-card">
                    <h3>구독자 참여도 분석</h3>
                    <div class="analytics-chart">
                        <div style="text-align: center;">
                            📈 <strong>참여도 향상 전략</strong><br><br>
                            <strong>댓글 참여 유도 방법:</strong><br>
                            • 영상 마지막에 질문 던지기<br>
                            • "여러분은 어떻게 생각하세요?" 활용<br>
                            • 댓글 이벤트 정기적 진행<br><br>
                            <strong>커뮤니티 활성화:</strong><br>
                            • 주 2-3회 커뮤니티 포스트<br>
                            • 구독자 의견 적극 수용<br>
                            • 라이브 스트림으로 실시간 소통
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 전역 변수
        let canvas, ctx;
        let selectedFont = 'Noto Sans KR'; // Default to a Korean-supported font
        let selectedColor = '#ffffff';
        let selectedStrokeColor = '#000000';
        let currentFontSize = 80;
        let currentStrokeWidth = 5;
        let currentShadowBlur = 8;
        let currentShadowDistance = 4;
        let currentSkew = 0;
        let currentPositionX = 640; // Initial X position (center)
        let currentPositionY = 360; // Initial Y position (center)
        let subtitles = [];
        let schedules = [];
        let textObjects = []; // Stores confirmed text objects on canvas
        let selectedTextIndex = -1; // Index of the currently selected text object
        let previewText = null; // Stores the text currently being typed in the input for live preview
        let backgroundOverlayColor = '#000000';
        let backgroundOverlayOpacity = 0; // 0-100 scale

        // Background Image Position and Size
        let currentBackgroundImageX = 0;
        let currentBackgroundImageY = 0;
        let currentBackgroundImageWidth = 1280;
        let currentBackgroundImageHeight = 720;
        let currentLoadedBackgroundImage = null; // Stores the actual Image object for the background

        // Undo/Redo stacks
        let undoStack = [];
        let redoStack = [];

        // Base values for proportional scaling of shadow/glow
        const baseFontSizeForShadow = 80;
        const baseShadowBlur = 8;
        const baseShadowDistance = 4;

        // Lost Ark themed color palette
        const lostArkColors = [
            '#FFFFFF', '#FFD700', '#FF8C00', '#DC143C', '#4169E1', '#9932CC',
            '#000000', '#8B0000', '#006400', '#4B0082', '#FF4500', '#00CED1',
            '#C0C0C0', '#B8860B', '#2F4F4F', '#8A2BE2', '#FF1493', '#7FFF00'
        ];

        // List of all fonts to ensure they are loaded
        // Prioritizing Korean-supported fonts based on user feedback
        const allFonts = [
            'Noto Sans KR', 'Roboto', // General purpose, often include CJK subsets
            'Black Han Sans', 'Do Hyeon', 'Jua', 'Gothic A1', 'Sunflower', // Popular bold Korean fonts
            'Nanum Gothic', 'Nanum Myeongjo', 'Nanum Pen Script' // Other Nanum series for variety
        ];

        // Font style templates
        const fontStyleTemplates = {
            modernBold: {
                font: 'Noto Sans KR',
                size: 100,
                color: '#FFFFFF',
                strokeColor: '#333333',
                strokeWidth: 6,
                shadowBlur: 10,
                shadowDistance: 5,
                skew: 0
            },
            classicSerif: {
                font: 'Nanum Myeongjo',
                size: 80,
                color: '#FFD700', // Gold
                strokeColor: '#5C4033', // Brown
                strokeWidth: 4,
                shadowBlur: 8,
                shadowDistance: 3,
                skew: 0
            },
            handwrittenFun: {
                font: 'Nanum Pen Script',
                size: 90,
                color: '#4ECDC4', // Teal
                strokeColor: '#FFFFFF',
                strokeWidth: 2,
                shadowBlur: 15,
                shadowDistance: 0,
                skew: 5
            },
            impactfulHeadline: {
                font: 'Black Han Sans',
                size: 120,
                color: '#FF6B6B', // Red
                strokeColor: '#000000', // Black
                strokeWidth: 10,
                shadowBlur: 20,
                shadowDistance: 8,
                skew: -8
            },
            futuristicTech: {
                font: 'Gothic A1',
                size: 95,
                color: '#00FFFF', // Cyan
                strokeColor: '#0F3460', // Dark Blue
                strokeWidth: 7,
                shadowBlur: 18,
                shadowDistance: 4,
                skew: 10
            },
            // New Clean Templates (based on user request and images)
            boldOutlineYellow: {
                font: 'Black Han Sans',
                size: 100,
                color: '#FFD700', // Gold/Yellow
                strokeColor: '#000000', // Black
                strokeWidth: 8,
                shadowBlur: 0, // No glow
                shadowDistance: 0,
                skew: 0
            },
            boldOutlinePinkOrange: {
                font: 'Do Hyeon',
                size: 95,
                color: '#FF69B4', // Hot Pink
                strokeColor: '#000000', // Black
                strokeWidth: 7,
                shadowBlur: 0, // No glow
                shadowDistance: 0,
                skew: 0
            },
            minimalistSans: {
                font: 'Noto Sans KR',
                size: 70,
                color: '#E5E5E7', // Light Grey/White
                strokeColor: '#000000', // No visible stroke
                strokeWidth: 0,
                shadowBlur: 0, // No shadow/glow
                shadowDistance: 0,
                skew: 0
            },
            elegantThin: {
                font: 'Nanum Myeongjo', // Good for elegant thin look
                size: 60,
                color: '#ADD8E6', // Light Blue
                strokeColor: '#000000', // No visible stroke
                strokeWidth: 0,
                shadowBlur: 0, // No shadow/glow
                shadowDistance: 0,
                skew: 0
            },
            retroBlock: {
                font: 'Jua', // Blocky, playful
                size: 110,
                color: '#F0E68C', // Khaki/Yellowish
                strokeColor: '#8B4513', // SaddleBrown
                strokeWidth: 9,
                shadowBlur: 0, // No shadow/glow
                shadowDistance: 0,
                skew: 0
            }
        };


        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Load all fonts first
            const fontPromises = allFonts.map(fontName => {
                let fontLoadString = `bold 12px "${fontName}"`;
                if (fontName === 'Gothic A1' || fontName === 'Nanum Gothic' || fontName === 'Nanum Myeongjo') {
                    fontLoadString = `900 12px "${fontName}"`; // Request extra bold for these
                } else if (fontName === 'Sunflower') {
                    fontLoadString = `700 12px "${fontName}"`; // Request bold for Sunflower
                }
                return document.fonts.load(fontLoadString);
            });

            Promise.all(fontPromises)
                .then(() => {
                    console.log('All fonts loaded successfully.');
                    initializeThumbnailEditor();
                    initializeLostArkColorPalette();
                    // Display initial welcome notification after fonts are ready
                    setTimeout(() => {
                        showNotification('⚔️ 로스트아크 유튜버 전용 도구에 오신 것을 환영합니다! 🏆', 'success');
                    }, 1000);
                    saveCanvasState(); // Save initial empty state after canvas is ready
                })
                .catch(error => {
                    console.error('Error loading fonts:', error);
                    showNotification('폰트 로딩 중 오류가 발생했습니다. 일부 폰트가 제대로 표시되지 않을 수 있습니다.', 'error');
                    // Proceed with initialization even if fonts fail to load
                    initializeThumbnailEditor();
                    initializeLostArkColorPalette();
                    setTimeout(() => {
                        showNotification('⚔️ 로스트아크 유튜버 전용 도구에 오신 것을 환영합니다! 🏆', 'success');
                    }, 1000);
                    saveCanvasState(); // Save initial empty state even if fonts failed
                });

            // Add event listeners for subtitle style inputs
            document.getElementById('subtitleFont').addEventListener('change', updateSubtitlePreview);
            document.getElementById('subtitleFontSize').addEventListener('change', updateSubtitlePreview);
            document.getElementById('subtitlePosition').addEventListener('change', updateSubtitlePreview);
            document.getElementById('subtitleTextColor').addEventListener('input', updateSubtitlePreview);
            document.getElementById('subtitleBgColor').addEventListener('input', updateSubtitlePreview);
            document.getElementById('subtitleBgOpacity').addEventListener('input', () => {
                document.getElementById('subtitleBgOpacityValue').textContent = document.getElementById('subtitleBgOpacity').value;
                updateSubtitlePreview();
            });

            // Initialize position sliders values
            document.getElementById('positionX').value = currentPositionX;
            document.getElementById('positionY').value = currentPositionY;
            document.getElementById('positionXValue').textContent = currentPositionX;
            document.getElementById('positionYValue').textContent = currentPositionY;

            // Initialize background image sliders
            document.getElementById('bgImageX').value = currentBackgroundImageX;
            document.getElementById('bgImageY').value = currentBackgroundImageY;
            document.getElementById('bgImageWidth').value = currentBackgroundImageWidth;
            document.getElementById('bgImageHeight').value = currentBackgroundImageHeight;
            document.getElementById('bgImageXValue').textContent = currentBackgroundImageX;
            document.getElementById('bgImageYValue').textContent = currentBackgroundImageY;
            document.getElementById('bgImageWidthValue').textContent = currentBackgroundImageWidth;
            document.getElementById('bgImageHeightValue').textContent = currentBackgroundImageHeight;

            // Initialize background overlay sliders
            document.getElementById('backgroundOverlayColor').value = backgroundOverlayColor;
            document.getElementById('backgroundOverlayOpacity').value = backgroundOverlayOpacity;
            document.getElementById('backgroundOverlayOpacityValue').textContent = backgroundOverlayOpacity;
        });

        /**
         * Switches between different tool tabs.
         * @param {Event} event - The click event from the tab button.
         * @param {string} tabName - The ID of the tab section to display.
         */
        function showTab(event, tabName) {
            // Deactivate all tool sections
            document.querySelectorAll('.tool-section').forEach(section => {
                section.classList.remove('active');
            });
            // Deactivate all tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Activate the selected tab section and button
            document.getElementById(tabName).classList.add('active');
            // Use event.currentTarget instead of event.target to ensure the button itself is selected, not an icon inside it
            event.currentTarget.classList.add('active');
        }

        /**
         * Initializes the thumbnail canvas editor.
         * Sets up the canvas context and initial background.
         * Attaches mouse event listeners for text selection (dragging removed).
         */
        function initializeThumbnailEditor() {
            canvas = document.getElementById('thumbnailCanvas');
            ctx = canvas.getContext('2d');
            
            // Initial canvas background - Lost Ark style gradient
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(0.5, '#16213e');
            gradient.addColorStop(1, '#0f3460');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Canvas event listeners for selecting text (dragging removed)
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove); // Still used for cursor change
            canvas.addEventListener('mouseup', handleMouseUp); // Still used to reset cursor
            canvas.addEventListener('click', handleCanvasClick);
        }

        /**
         * Initializes the color palettes for text and stroke colors.
         * Populates the palettes with predefined Lost Ark themed colors.
         */
        function initializeLostArkColorPalette() {
            const colorPalette = document.getElementById('colorPalette');
            const strokeColorPalette = document.getElementById('strokeColorPalette');
            
            // Populate text color palette
            if (colorPalette) {
                colorPalette.innerHTML = '';
                lostArkColors.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = color;
                    if (color.toLowerCase() === selectedColor.toLowerCase()) swatch.classList.add('active');
                    swatch.onclick = () => selectColor(color, swatch);
                    colorPalette.appendChild(swatch);
                });
            }

            // Populate stroke color palette
            if (strokeColorPalette) {
                strokeColorPalette.innerHTML = '';
                lostArkColors.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = color;
                    if (color.toLowerCase() === selectedStrokeColor.toLowerCase()) swatch.classList.add('active');
                    swatch.onclick = () => selectStrokeColor(color, swatch);
                    strokeColorPalette.appendChild(swatch);
                });
            }
        }

        /**
         * Selects a text color from the palette and updates the UI.
         * @param {string} color - The hexadecimal color code.
         * @param {HTMLElement} element - The color swatch element that was clicked.
         */
        function selectColor(color, element) {
            selectedColor = color;
            document.querySelectorAll('#colorPalette .color-swatch').forEach(s => s.classList.remove('active'));
            element.classList.add('active');
            document.getElementById('customColor').value = color; // Update custom color picker
            updatePreviewText(); // Update canvas preview
        }

        /**
         * Selects a stroke color from the palette and updates the UI.
         * @param {string} color - The hexadecimal color code.
         * @param {HTMLElement} element - The color swatch element that was clicked.
         */
        function selectStrokeColor(color, element) {
            selectedStrokeColor = color;
            document.querySelectorAll('#strokeColorPalette .color-swatch').forEach(s => s.classList.remove('active'));
            element.classList.add('active');
            document.getElementById('strokeColor').value = color; // Update custom color picker
            updatePreviewText(); // Update canvas preview
        }

        /**
         * Selects a font from the font options and updates the UI.
         * @param {HTMLElement} element - The font option element that was clicked.
         */
        function selectFont(element) {
            document.querySelectorAll('.font-option').forEach(f => f.classList.remove('active'));
            element.classList.add('active');
            selectedFont = element.dataset.font;
            updatePreviewText(); // Update canvas preview
        }

        /** Updates font size based on slider input. */
        function updateFontSize() {
            currentFontSize = parseInt(document.getElementById('fontSize').value);
            document.getElementById('fontSizeValue').textContent = currentFontSize;

            // Automatically scale shadow blur and distance based on font size
            // This ensures shadows grow/shrink proportionally with text
            currentShadowBlur = Math.round(currentFontSize * (baseShadowBlur / baseFontSizeForShadow));
            currentShadowDistance = Math.round(currentFontSize * (baseShadowDistance / baseFontSizeForShadow));

            // Update the UI sliders for shadow blur and distance
            document.getElementById('shadowBlur').value = currentShadowBlur;
            document.getElementById('shadowBlurValue').textContent = currentShadowBlur;
            document.getElementById('shadowDistance').value = currentShadowDistance;
            document.getElementById('shadowDistanceValue').textContent = currentShadowDistance;

            updatePreviewText();
        }

        /** Updates stroke width based on slider input. */
        function updateStrokeWidth() {
            currentStrokeWidth = document.getElementById('strokeWidth').value;
            document.getElementById('strokeWidthValue').textContent = currentStrokeWidth;
            updatePreviewText();
        }

        /** Updates shadow blur based on slider input. */
        function updateShadowBlur() {
            currentShadowBlur = document.getElementById('shadowBlur').value;
            document.getElementById('shadowBlurValue').textContent = currentShadowBlur;
            updatePreviewText();
        }

        /** Updates shadow distance based on slider input. */
        function updateShadowDistance() {
            currentShadowDistance = document.getElementById('shadowDistance').value;
            document.getElementById('shadowDistanceValue').textContent = currentShadowDistance;
            updatePreviewText();
        }

        /** Updates skew angle based on slider input. */
        function updateSkew() {
            currentSkew = document.getElementById('skewAngle').value;
            document.getElementById('skewValue').textContent = currentSkew;
            updatePreviewText();
        }

        /** Updates selected color from custom color picker and reflects in palette. */
        function updateSelectedColor() {
            const color = document.getElementById('customColor').value;
            selectedColor = color;
            // Remove active class from all swatches
            document.querySelectorAll('#colorPalette .color-swatch').forEach(s => s.classList.remove('active'));
            // Find and activate the matching swatch, if any
            const matchingSwatch = Array.from(document.querySelectorAll('#colorPalette .color-swatch')).find(s => s.style.backgroundColor.toLowerCase() === color.toLowerCase());
            if (matchingSwatch) {
                matchingSwatch.classList.add('active');
            }
            updatePreviewText();
        }

        /** Updates stroke color from custom color picker and reflects in palette. */
        function updateStrokeColor() {
            const color = document.getElementById('strokeColor').value;
            selectedStrokeColor = color;
            // Remove active class from all swatches
            document.querySelectorAll('#strokeColorPalette .color-swatch').forEach(s => s.classList.remove('active'));
            // Find and activate the matching swatch, if any
            const matchingSwatch = Array.from(document.querySelectorAll('#strokeColorPalette .color-swatch')).find(s => s.style.backgroundColor.toLowerCase() === color.toLowerCase());
            if (matchingSwatch) {
                matchingSwatch.classList.add('active');
            }
            updatePreviewText();
        }

        /** Updates X position based on slider input. */
        function updatePositionX() {
            currentPositionX = parseInt(document.getElementById('positionX').value);
            document.getElementById('positionXValue').textContent = currentPositionX;
            if (selectedTextIndex !== -1) {
                textObjects[selectedTextIndex].x = currentPositionX;
                saveCanvasState(); // Save state after position change
            } else if (previewText) {
                previewText.x = currentPositionX;
            }
            redrawCanvas();
        }

        /** Updates Y position based on slider input. */
        function updatePositionY() {
            currentPositionY = parseInt(document.getElementById('positionY').value);
            document.getElementById('positionYValue').textContent = currentPositionY;
            if (selectedTextIndex !== -1) {
                textObjects[selectedTextIndex].y = currentPositionY;
                saveCanvasState(); // Save state after position change
            } else if (previewText) {
                previewText.y = currentPositionY;
            }
            redrawCanvas();
        }

        /**
         * Updates the background overlay color and opacity based on slider input.
         */
        function updateBackgroundOverlay() {
            backgroundOverlayColor = document.getElementById('backgroundOverlayColor').value;
            backgroundOverlayOpacity = parseInt(document.getElementById('backgroundOverlayOpacity').value); // Parse to int for 0-100 scale
            document.getElementById('backgroundOverlayOpacityValue').textContent = backgroundOverlayOpacity;
            redrawCanvas();
            saveCanvasState(); // Save state after overlay change
        }

        /**
         * Updates the background image position and size based on slider inputs.
         */
        function updateBackgroundImagePosition() {
            currentBackgroundImageX = parseInt(document.getElementById('bgImageX').value);
            currentBackgroundImageY = parseInt(document.getElementById('bgImageY').value);
            currentBackgroundImageWidth = parseInt(document.getElementById('bgImageWidth').value);
            currentBackgroundImageHeight = parseInt(document.getElementById('bgImageHeight').value);

            document.getElementById('bgImageXValue').textContent = currentBackgroundImageX;
            document.getElementById('bgImageYValue').textContent = currentBackgroundImageY;
            document.getElementById('bgImageWidthValue').textContent = currentBackgroundImageWidth;
            document.getElementById('bgImageHeightValue').textContent = currentBackgroundImageHeight;

            redrawCanvas();
            saveCanvasState(); // Save state after image position/size change
        }

        /**
         * Updates the real-time text preview on the canvas based on current input and styles.
         */
        function updatePreviewText() {
            const text = document.getElementById('thumbnailText').value.trim(); // Use .trim() to handle empty string correctly
            if (!text) {
                if (previewText) {
                    previewText = null; // Clear preview if input is empty
                    redrawCanvas();
                }
                return;
            }

            // Create or update the preview text object
            previewText = {
                text: text,
                x: currentPositionX, // Use current slider X position for preview
                y: currentPositionY, // Use current slider Y position for preview
                font: selectedFont,
                size: currentFontSize,
                color: selectedColor,
                strokeColor: selectedStrokeColor,
                strokeWidth: currentStrokeWidth,
                shadowBlur: currentShadowBlur,
                shadowDistance: currentShadowDistance,
                skew: currentSkew,
                isPreview: true // Flag to indicate it's a preview
            };

            redrawCanvas(); // Redraw canvas with updated preview
        }

        /**
         * Updates the list of confirmed text items displayed below the canvas.
         * Allows users to select a text item for editing.
         */
        function updateConfirmedTextList() {
            const listContainer = document.getElementById('confirmedTextList');
            if (!listContainer) return; // Ensure element exists

            if (textObjects.length === 0) {
                listContainer.innerHTML = '<p style="opacity: 0.7; text-align: center;">확정된 텍스트가 없습니다.</p>';
                return;
            }

            listContainer.innerHTML = textObjects.map((textObj, index) => `
                <div class="confirmed-text-item ${index === selectedTextIndex ? 'selected' : ''}" onclick="selectConfirmedText(${index})">
                    <span>${textObj.text.length > 20 ? textObj.text.substring(0, 17) + '...' : textObj.text}</span>
                    <small style="opacity: 0.7;">(${textObj.font}, ${textObj.size}px)</small>
                </div>
            `).join('');
        }

        /**
         * Selects a text object from the confirmed list and loads its properties into the controls.
         * @param {number} index - The index of the text object to select.
         */
        function selectConfirmedText(index) {
            if (index < 0 || index >= textObjects.length) return;

            selectedTextIndex = index;
            const textObj = textObjects[selectedTextIndex];

            // Update all controls to reflect selected text's properties
            document.getElementById('thumbnailText').value = textObj.text;
            
            selectedFont = textObj.font;
            document.querySelectorAll('.font-option').forEach(f => {
                f.classList.remove('active');
                if (f.dataset.font === selectedFont) f.classList.add('active');
            });

            currentFontSize = textObj.size;
            document.getElementById('fontSize').value = currentFontSize;
            document.getElementById('fontSizeValue').textContent = currentFontSize;

            currentSkew = textObj.skew;
            document.getElementById('skewAngle').value = currentSkew;
            document.getElementById('skewValue').textContent = currentSkew;

            currentPositionX = Math.round(textObj.x);
            currentPositionY = Math.round(textObj.y);
            document.getElementById('positionX').value = currentPositionX;
            document.getElementById('positionY').value = currentPositionY;
            document.getElementById('positionXValue').textContent = currentPositionX;
            document.getElementById('positionYValue').textContent = currentPositionY;

            selectedColor = textObj.color;
            document.getElementById('customColor').value = selectedColor;
            document.querySelectorAll('#colorPalette .color-swatch').forEach(s => {
                s.classList.remove('active');
                if (s.style.backgroundColor.toLowerCase() === selectedColor.toLowerCase()) s.classList.add('active');
            });

            selectedStrokeColor = textObj.strokeColor;
            document.getElementById('strokeColor').value = selectedStrokeColor;
            document.querySelectorAll('#strokeColorPalette .color-swatch').forEach(s => {
                s.classList.remove('active');
                if (s.style.backgroundColor.toLowerCase() === selectedStrokeColor.toLowerCase()) s.classList.add('active');
            });

            currentStrokeWidth = textObj.strokeWidth;
            document.getElementById('strokeWidth').value = currentStrokeWidth;
            document.getElementById('strokeWidthValue').textContent = currentStrokeWidth;

            currentShadowBlur = textObj.shadowBlur;
            document.getElementById('shadowBlur').value = currentShadowBlur;
            document.getElementById('shadowBlurValue').textContent = currentShadowBlur;

            currentShadowDistance = textObj.shadowDistance;
            document.getElementById('shadowDistance').value = currentShadowDistance;
            document.getElementById('shadowDistanceValue').textContent = currentShadowDistance;

            redrawCanvas(); // Redraw canvas to highlight selected text
            showNotification(`'${textObj.text.substring(0, 15)}...' 텍스트가 선택되었습니다.`, 'info');
        }


        /**
         * Redraws all elements on the canvas (background, confirmed texts, and preview text).
         */
        function redrawCanvas() {
            // Clear entire canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. Draw current background image if exists
            if (currentLoadedBackgroundImage) { // Use currentLoadedBackgroundImage for drawing
                ctx.drawImage(currentLoadedBackgroundImage, currentBackgroundImageX, currentBackgroundImageY, currentBackgroundImageWidth, currentBackgroundImageHeight);
            } else {
                // Default background if no template or image is active
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(0.5, '#16213e');
                gradient.addColorStop(1, '#0f3460');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // 2. Draw current template as an overlay if exists
            if (canvas.currentTemplate) {
                ctx.save();
                ctx.globalAlpha = 0.7; // Apply a default transparency for templates as overlays
                const templates = {
                    lostark_dark: () => {
                        const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)/2);
                        gradient.addColorStop(0, '#2c1810');
                        gradient.addColorStop(0.7, '#1a1a2e');
                        gradient.addColorStop(1, '#000000');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    },
                    lostark_gold: () => {
                        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                        gradient.addColorStop(0, '#ffd700');
                        gradient.addColorStop(0.3, '#ff8c00');
                        gradient.addColorStop(0.7, '#b8860b');
                        gradient.addColorStop(1, '#8b7355');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    },
                    lostark_fire: () => {
                        const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)/2);
                        gradient.addColorStop(0, '#ff4500');
                        gradient.addColorStop(0.4, '#dc143c');
                        gradient.addColorStop(0.8, '#8b0000');
                        gradient.addColorStop(1, '#2f1b14');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    },
                    lostark_ice: () => {
                        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                        gradient.addColorStop(0, '#87ceeb');
                        gradient.addColorStop(0.3, '#4169e1');
                        gradient.addColorStop(0.7, '#191970');
                        gradient.addColorStop(1, '#0f0f2f');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    },
                    lostark_nature: () => {
                        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                        gradient.addColorStop(0, '#90ee90');
                        gradient.addColorStop(0.3, '#32cd32');
                        gradient.addColorStop(0.7, '#228b22');
                        gradient.addColorStop(1, '#0f2f0f');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    },
                    lostark_purple: () => {
                        const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)/2);
                        gradient.addColorStop(0, '#da70d6');
                        gradient.addColorStop(0.4, '#9932cc');
                        gradient.addColorStop(0.8, '#4b0082');
                        gradient.addColorStop(1, '#1a0a1a');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                };
                templates[canvas.currentTemplate]();
                ctx.restore();
            }

            // 3. Apply background overlay if opacity is greater than 0
            if (backgroundOverlayOpacity > 0) {
                ctx.save();
                ctx.fillStyle = backgroundOverlayColor;
                ctx.globalAlpha = backgroundOverlayOpacity / 100;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }

            // Draw all confirmed text objects
            textObjects.forEach((textObj, index) => {
                drawText(textObj, index === selectedTextIndex);
            });

            // Draw the live preview text (if any)
            if (previewText) {
                drawText(previewText, false, true);
            }

            // Update the confirmed text list UI
            updateConfirmedTextList();
        }

        /**
         * Draws a single text object on the canvas with its properties.
         * @param {object} textObj - The text object containing text, position, and style properties.
         * @param {boolean} isSelected - True if the text is currently selected.
         * @param {boolean} isPreview - True if the text is a live preview.
         */
        function drawText(textObj, isSelected = false, isPreview = false) {
            ctx.save(); // Save current canvas state

            // Apply skew transformation if specified
            if (textObj.skew && textObj.skew !== 0) {
                // To apply skew around the text's center, translate, skew, then translate back
                ctx.translate(textObj.x, textObj.y);
                ctx.transform(1, 0, Math.tan(textObj.skew * Math.PI / 180), 1, 0, 0);
                ctx.translate(-textObj.x, -textObj.y);
            }

            // Set font - crucial for correct rendering
            ctx.font = `bold ${textObj.size}px "${textObj.font}"`; // Ensure font name is quoted for custom fonts
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Apply shadow effects (glow effect)
            // Only apply shadow if shadowBlur is greater than 0
            if (textObj.shadowBlur > 0) {
                ctx.shadowColor = textObj.color; // For glow, shadow color matches text color
                ctx.shadowBlur = parseInt(textObj.shadowBlur);
                ctx.shadowOffsetX = parseInt(textObj.shadowDistance);
                ctx.shadowOffsetY = parseInt(textObj.shadowDistance);
            }
            
            // Draw text stroke if defined
            if (textObj.strokeWidth && textObj.strokeWidth > 0) {
                ctx.strokeStyle = textObj.strokeColor;
                ctx.lineWidth = parseInt(textObj.strokeWidth);
                ctx.strokeText(textObj.text, textObj.x, textObj.y);
            }
            
            // Draw text fill
            ctx.fillStyle = isPreview ? 'rgba(255,255,255,0.7)' : textObj.color; // Make preview text slightly transparent
            ctx.fillText(textObj.text, textObj.x, textObj.y);
            
            // Draw selection border if selected and not a preview, and not during download
            // The `downloadThumbnail` function temporarily sets `selectedTextIndex = -1` and `previewText = null`
            // before redrawing for download, so this `if` condition correctly prevents drawing during download.
            if (isSelected && !isPreview) {
                ctx.strokeStyle = '#ffd700'; // Gold border for selection
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]); // Dashed line
                const metrics = ctx.measureText(textObj.text);
                const width = metrics.width + 20; // Add padding
                const height = textObj.size + 20; // Add padding
                ctx.strokeRect(textObj.x - width/2, textObj.y - height/2, width, height);
                ctx.setLineDash([]); // Reset line dash
            }
            
            // Reset shadow properties for subsequent drawings
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.restore(); // Restore canvas state
        }

        /**
         * Confirms the current preview text and adds it as a permanent object on the canvas.
         */
        function confirmText() {
            const text = document.getElementById('thumbnailText').value.trim();
            if (!text) {
                showNotification('텍스트를 입력해주세요.', 'error');
                return;
            }

            // Create a new text object from current preview settings
            const textObj = {
                text: text,
                x: currentPositionX, // Use current slider X position for new text
                y: currentPositionY, // Use current slider Y position for new text
                font: selectedFont,
                size: currentFontSize,
                color: selectedColor,
                strokeColor: selectedStrokeColor,
                strokeWidth: currentStrokeWidth,
                shadowBlur: currentShadowBlur,
                shadowDistance: currentShadowDistance,
                skew: currentSkew
            };

            textObjects.push(textObj); // Add to the array of confirmed texts
            previewText = null; // Clear the live preview
            selectedTextIndex = textObjects.length - 1; // Select the newly added text
            
            document.getElementById('thumbnailText').value = ''; // Clear text input
            
            redrawCanvas(); // Redraw canvas to show the new permanent text
            saveCanvasState(); // Save state after adding text
            showNotification('텍스트가 추가되었습니다! 위치 조정 버튼을 사용하세요.', 'success');
        }

        /**
         * Handles mouse down events on the canvas for text selection.
         * Dragging functionality is removed.
         * @param {MouseEvent} event - The mouse down event.
         */
        function handleMouseDown(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;    // Relationship bitmap vs. element for x
            const scaleY = canvas.height / rect.height;  // Relationship bitmap vs. element for y
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;
            
            // Iterate through text objects in reverse to select the topmost one
            for (let i = textObjects.length - 1; i >= 0; i--) {
                const textObj = textObjects[i];
                ctx.font = `bold ${textObj.size}px "${textObj.font}"`;
                const metrics = ctx.measureText(textObj.text);
                const width = metrics.width;
                const height = textObj.size;
                
                // Check if mouse click is within the text bounding box
                if (x >= textObj.x - width/2 && x <= textObj.x + width/2 &&
                    y >= textObj.y - height/2 && y <= textObj.y + height/2) {
                    selectedTextIndex = i; // Select this text object
                    // Update sliders to reflect selected text's position
                    currentPositionX = Math.round(textObj.x);
                    currentPositionY = Math.round(textObj.y);
                    document.getElementById('positionX').value = currentPositionX;
                    document.getElementById('positionY').value = currentPositionY;
                    document.getElementById('positionXValue').textContent = currentPositionX;
                    document.getElementById('positionYValue').textContent = currentPositionY;

                    // Update other controls for selected text
                    selectedFont = textObj.font;
                    currentFontSize = textObj.size;
                    selectedColor = textObj.color;
                    selectedStrokeColor = textObj.strokeColor;
                    currentStrokeWidth = textObj.strokeWidth;
                    currentShadowBlur = textObj.shadowBlur;
                    currentShadowDistance = textObj.shadowDistance;
                    currentSkew = textObj.skew;

                    // Update UI elements to reflect selected text's styles
                    document.getElementById('thumbnailText').value = textObj.text;
                    document.getElementById('fontSize').value = currentFontSize;
                    document.getElementById('fontSizeValue').textContent = currentFontSize;
                    document.getElementById('skewAngle').value = currentSkew;
                    document.getElementById('skewValue').textContent = currentSkew;
                    document.getElementById('strokeWidth').value = currentStrokeWidth;
                    document.getElementById('strokeWidthValue').textContent = currentStrokeWidth;
                    document.getElementById('shadowBlur').value = currentShadowBlur;
                    document.getElementById('shadowBlurValue').textContent = currentShadowBlur;
                    document.getElementById('shadowDistance').value = currentShadowDistance;
                    document.getElementById('shadowDistanceValue').textContent = currentShadowDistance;
                    document.getElementById('customColor').value = selectedColor;
                    document.getElementById('strokeColor').value = selectedStrokeColor;
                    
                    // Update font and color active states in UI
                    document.querySelectorAll('.font-option').forEach(f => {
                        f.classList.remove('active');
                        if (f.dataset.font === selectedFont) f.classList.add('active');
                    });
                    document.querySelectorAll('#colorPalette .color-swatch').forEach(s => {
                        s.classList.remove('active');
                        if (s.style.backgroundColor.toLowerCase() === selectedColor.toLowerCase()) s.classList.add('active');
                    });
                    document.querySelectorAll('#strokeColorPalette .color-swatch').forEach(s => {
                        s.classList.remove('active');
                        if (s.style.backgroundColor.toLowerCase() === selectedStrokeColor.toLowerCase()) s.classList.add('active');
                    });

                    redrawCanvas(); // Redraw to show selection
                    showNotification('텍스트가 선택되었습니다. 위치 조정 버튼을 사용하세요.', 'info');
                    return; // Stop after finding the first clicked text
                }
            }
            
            // If no text was clicked, deselect any currently selected text
            selectedTextIndex = -1;
            redrawCanvas();
        }

        /**
         * Handles mouse move events on the canvas for cursor change.
         * Dragging functionality is removed.
         * @param {MouseEvent} event - The mouse move event.
         */
        function handleMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;

            let overText = false;
            for (let i = textObjects.length - 1; i >= 0; i--) {
                const textObj = textObjects[i];
                ctx.font = `bold ${textObj.size}px "${textObj.font}"`;
                const metrics = ctx.measureText(textObj.text);
                const width = metrics.width;
                const height = textObj.size;
                
                if (x >= textObj.x - width/2 && x <= textObj.x + width/2 &&
                    y >= textObj.y - height/2 && y <= textObj.y + height/2) {
                    overText = true;
                    break;
                }
            }
            canvas.style.cursor = overText ? 'pointer' : 'crosshair'; // Change to pointer when hovering over text
        }

        /**
         * Handles mouse up events on the canvas.
         * Dragging functionality is removed.
         * @param {MouseEvent} event - The mouse up event.
         */
        function handleMouseUp(event) {
            // No dragging logic here anymore, just reset cursor if needed
            canvas.style.cursor = 'crosshair';
        }

        /**
         * Handles click events on the canvas for selecting text objects.
         * This function is now more focused on selection.
         * @param {MouseEvent} event - The click event.
         */
        function handleCanvasClick(event) {
            // handleMouseDown already covers selection, this might be redundant if not for specific click actions
            // but keeping it for consistency if future click-only actions are added.
        }

        /**
         * Positions the currently selected text object (or preview text) on the canvas.
         * @param {string} positionType - The desired position ('topLeft', 'center', 'bottomRight', etc.).
         */
        function positionText(positionType) {
            let targetTextObj = null;

            if (selectedTextIndex !== -1) {
                targetTextObj = textObjects[selectedTextIndex];
            } else if (previewText) {
                targetTextObj = previewText;
            } else {
                showNotification('위치를 조정할 텍스트를 먼저 입력하거나 선택해주세요.', 'info');
                return;
            }

            // Calculate text dimensions for accurate positioning
            ctx.font = `bold ${targetTextObj.size}px "${targetTextObj.font}"`;
            const metrics = ctx.measureText(targetTextObj.text);
            const textWidth = metrics.width;
            const textHeight = targetTextObj.size; // Approximate height based on font size

            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;

            const padding = 20; // Padding from edges

            switch (positionType) {
                case 'topLeft':
                    targetTextObj.x = textWidth / 2 + padding;
                    targetTextObj.y = textHeight / 2 + padding;
                    break;
                case 'topCenter':
                    targetTextObj.x = canvasWidth / 2;
                    targetTextObj.y = textHeight / 2 + padding;
                    break;
                case 'topRight':
                    targetTextObj.x = canvasWidth - textWidth / 2 - padding;
                    targetTextObj.y = textHeight / 2 + padding;
                    break;
                case 'middleLeft':
                    targetTextObj.x = textWidth / 2 + padding;
                    targetTextObj.y = canvasHeight / 2;
                    break;
                case 'center':
                    targetTextObj.x = canvasWidth / 2;
                    targetTextObj.y = canvasHeight / 2;
                    break;
                case 'middleRight':
                    targetTextObj.x = canvasWidth - textWidth / 2 - padding;
                    targetTextObj.y = canvasHeight / 2;
                    break;
                case 'bottomLeft':
                    targetTextObj.x = textWidth / 2 + padding;
                    targetTextObj.y = canvasHeight - textHeight / 2 - padding;
                    break;
                case 'bottomCenter':
                    targetTextObj.x = canvasWidth / 2;
                    targetTextObj.y = canvasHeight - textHeight / 2 - padding;
                    break;
                case 'bottomRight':
                    targetTextObj.x = canvasWidth - textWidth / 2 - padding;
                    targetTextObj.y = canvasHeight - textHeight / 2 - padding;
                    break;
            }
            
            // Update sliders to reflect the new position
            currentPositionX = Math.round(targetTextObj.x);
            currentPositionY = Math.round(targetTextObj.y);
            document.getElementById('positionX').value = currentPositionX;
            document.getElementById('positionY').value = currentPositionY;
            document.getElementById('positionXValue').textContent = currentPositionX;
            document.getElementById('positionYValue').textContent = currentPositionY;

            redrawCanvas();
            saveCanvasState(); // Save state after positioning text
            showNotification(`텍스트가 ${positionType} 위치로 이동되었습니다.`, 'success');
        }

        /**
         * Deletes the currently selected text object from the canvas.
         */
        function deleteSelectedText() {
            if (selectedTextIndex !== -1) {
                textObjects.splice(selectedTextIndex, 1); // Remove from array
                selectedTextIndex = -1; // Deselect
                redrawCanvas(); // Redraw canvas
                saveCanvasState(); // Save state after deleting text
                showNotification('텍스트가 삭제되었습니다.', 'success');
            } else {
                showNotification('삭제할 텍스트를 먼저 선택해주세요.', 'info');
            }
        }

        /**
         * Saves the current canvas state (textObjects, currentLoadedBackgroundImage, currentTemplate, backgroundOverlayColor, backgroundOverlayOpacity, bgImageX/Y/Width/Height) to the undo stack.
         * Clears the redo stack.
         */
        function saveCanvasState() {
            const state = {
                textObjects: JSON.parse(JSON.stringify(textObjects)),
                // Store image source, not the image object itself, for serialization
                currentLoadedBackgroundImageSrc: currentLoadedBackgroundImage ? currentLoadedBackgroundImage.src : null,
                currentTemplate: canvas.currentTemplate,
                backgroundOverlayColor: backgroundOverlayColor,
                backgroundOverlayOpacity: backgroundOverlayOpacity,
                currentBackgroundImageX: currentBackgroundImageX,
                currentBackgroundImageY: currentBackgroundImageY,
                currentBackgroundImageWidth: currentBackgroundImageWidth,
                currentBackgroundImageHeight: currentBackgroundImageHeight
            };
            undoStack.push(state);
            redoStack = []; // Clear redo stack on new action
            console.log('Canvas state saved. Undo stack size:', undoStack.length);
        }

        /**
         * Restores a canvas state from the undo/redo stack.
         * @param {object} state - The state object to restore.
         */
        function restoreCanvasState(state) {
            textObjects = JSON.parse(JSON.stringify(state.textObjects));
            canvas.currentTemplate = state.currentTemplate;
            backgroundOverlayColor = state.backgroundOverlayColor;
            backgroundOverlayOpacity = state.backgroundOverlayOpacity;
            currentBackgroundImageX = state.currentBackgroundImageX;
            currentBackgroundImageY = currentBackgroundImageY;
            currentBackgroundImageWidth = state.currentBackgroundImageWidth;
            currentBackgroundImageHeight = state.currentBackgroundImageHeight;


            // Restore background image
            if (state.currentLoadedBackgroundImageSrc) {
                const img = new Image();
                img.onload = () => {
                    currentLoadedBackgroundImage = img; // Restore the Image object
                    redrawCanvas();
                };
                img.src = state.currentLoadedBackgroundImageSrc;
            } else {
                currentLoadedBackgroundImage = null; // Clear the image object
                redrawCanvas();
            }

            // Update UI for overlay
            document.getElementById('backgroundOverlayColor').value = backgroundOverlayColor;
            document.getElementById('backgroundOverlayOpacity').value = backgroundOverlayOpacity;
            document.getElementById('backgroundOverlayOpacityValue').textContent = backgroundOverlayOpacity;

            // Update UI for background image sliders
            document.getElementById('bgImageX').value = currentBackgroundImageX;
            document.getElementById('bgImageY').value = currentBackgroundImageY;
            document.getElementById('bgImageWidth').value = currentBackgroundImageWidth;
            document.getElementById('bgImageHeight').value = currentBackgroundImageHeight;
            document.getElementById('bgImageXValue').textContent = currentBackgroundImageX;
            document.getElementById('bgImageYValue').textContent = currentBackgroundImageY;
            document.getElementById('bgImageWidthValue').textContent = currentBackgroundImageWidth;
            document.getElementById('bgImageHeightValue').textContent = currentBackgroundImageHeight;


            selectedTextIndex = -1; // Deselect any text for simplicity
            redrawCanvas(); // Ensure canvas is redrawn after state restoration
        }

        /**
         * Undoes the last action on the canvas.
         */
        function undoCanvas() {
            if (undoStack.length > 1) { // Keep at least one state (the current one before undo)
                const currentState = undoStack.pop();
                redoStack.push(currentState); // Move current state to redo stack
                restoreCanvasState(undoStack[undoStack.length - 1]); // Apply previous state
                showNotification('실행 취소되었습니다.', 'info');
                console.log('Undo performed. Undo stack size:', undoStack.length);
            } else {
                showNotification('더 이상 되돌릴 작업이 없습니다.', 'info');
            }
        }

        /**
         * Redoes the last undone action on the canvas.
         */
        function redoCanvas() {
            if (redoStack.length > 0) {
                const undoneState = redoStack.pop();
                undoStack.push(undoneState); // Move state from redo to undo stack
                restoreCanvasState(undoneState); // Apply state
                showNotification('다시 실행되었습니다.', 'info');
                console.log('Redo performed. Undo stack size:', undoStack.length);
            } else {
                showNotification('더 이상 다시 실행할 작업이 없습니다.', 'info');
            }
        }

        /**
         * Loads a predefined Lost Ark themed background template onto the canvas.
         * @param {string} type - The type of template to load (e.g., 'lostark_dark', 'lostark_gold').
         */
        function loadTemplate(type) {
            canvas.currentTemplate = type; // Store current template type
            // Do NOT clear currentLoadedBackgroundImage here. It will be drawn underneath.
            redrawCanvas(); // Redraw to apply new background
            saveCanvasState(); // Save state after applying template
            showNotification(`${type.replace('lostark_', '').toUpperCase()} 템플릿이 적용되었습니다!`, 'success');
        }

        /**
         * Removes the currently applied background template overlay.
         */
        function removeBackgroundTemplate() {
            canvas.currentTemplate = null;
            redrawCanvas();
            saveCanvasState(); // Save state after removing template
            showNotification('배경 템플릿이 제거되었습니다.', 'success');
        }

        /**
         * Applies a predefined text style template (font, size, colors, effects)
         * to the current preview text settings.
         * @param {string} style - The name of the text style template (e.g., 'legendary', 'epic').
         */
        function applyTextTemplate(style) {
            const templates = {
                legendary: {
                    font: 'Black Han Sans', // Using a strong Korean font
                    size: 90,
                    color: '#ffd700', // Gold
                    strokeColor: '#8b0000', // Dark Red
                    strokeWidth: 8,
                    shadowBlur: 15,
                    shadowDistance: 6,
                    skew: -5
                },
                epic: {
                    font: 'Do Hyeon', // Using a strong Korean font
                    size: 85,
                    color: '#9932cc', // Dark Orchid
                    strokeColor: '#000000', // Black
                    strokeWidth: 6,
                    shadowBlur: 12,
                    shadowDistance: 5,
                    skew: 0
                },
                rare: {
                    font: 'Jua', // Using a strong Korean font
                    size: 80,
                    color: '#4169e1', // Royal Blue
                    strokeColor: '#ffffff', // White
                    strokeWidth: 4,
                    shadowBlur: 10,
                    shadowDistance: 4,
                    skew: 0
                },
                fire: {
                    font: 'Gothic A1', // Using a strong Korean font
                    size: 95,
                    color: '#ff4500', // Orange Red
                    strokeColor: '#8b0000', // Dark Red
                    strokeWidth: 10,
                    shadowBlur: 20,
                    shadowDistance: 8,
                    skew: 3
                }
            };

            const template = templates[style];
            if (template) {
                // Update global variables with template values
                selectedFont = template.font;
                currentFontSize = template.size;
                selectedColor = template.color;
                selectedStrokeColor = template.strokeColor;
                currentStrokeWidth = template.strokeWidth;
                currentShadowBlur = template.shadowBlur;
                currentShadowDistance = template.shadowDistance;
                currentSkew = template.skew;

                // Update UI controls to reflect new values
                document.querySelectorAll('.font-option').forEach(f => {
                    f.classList.remove('active');
                    if (f.dataset.font === template.font) f.classList.add('active');
                });
                document.getElementById('fontSize').value = template.size;
                document.getElementById('fontSizeValue').textContent = template.size;
                document.getElementById('strokeWidth').value = template.strokeWidth;
                document.getElementById('strokeWidthValue').textContent = template.strokeWidth;
                document.getElementById('shadowBlur').value = template.shadowBlur;
                document.getElementById('shadowBlurValue').textContent = template.shadowBlur;
                document.getElementById('shadowDistance').value = template.shadowDistance;
                document.getElementById('shadowDistanceValue').textContent = template.shadowDistance;
                document.getElementById('skewAngle').value = template.skew;
                document.getElementById('skewValue').textContent = template.skew;
                document.getElementById('customColor').value = template.color;
                document.getElementById('strokeColor').value = template.color; // Ensure stroke color matches for glow

                // Update color palette active states
                document.querySelectorAll('#colorPalette .color-swatch').forEach(swatch => {
                    swatch.classList.remove('active');
                    if (swatch.style.backgroundColor.toLowerCase() === template.color.toLowerCase()) {
                        swatch.classList.add('active');
                    }
                });
                document.querySelectorAll('#strokeColorPalette .color-swatch').forEach(swatch => {
                    swatch.classList.remove('active');
                    if (swatch.style.backgroundColor.toLowerCase() === template.strokeColor.toLowerCase()) {
                        swatch.classList.add('active');
                    }
                });

                updatePreviewText(); // Update canvas preview with new styles
                showNotification(`${style.toUpperCase()} 스타일이 적용되었습니다!`, 'success');
            }
        }

        /**
         * Applies a predefined font style template to the current preview text settings.
         * @param {string} templateName - The name of the font style template (e.g., 'modernBold').
         */
        function applyFontTemplate(templateName) {
            const template = fontStyleTemplates[templateName];
            if (template) {
                // Update global variables with template values
                selectedFont = template.font;
                currentFontSize = template.size;
                selectedColor = template.color;
                selectedStrokeColor = template.strokeColor;
                currentStrokeWidth = template.strokeWidth;
                currentShadowBlur = template.shadowBlur;
                currentShadowDistance = template.shadowDistance;
                currentSkew = template.skew;

                // Update UI controls to reflect new values
                document.querySelectorAll('.font-option').forEach(f => {
                    f.classList.remove('active');
                    if (f.dataset.font === template.font) f.classList.add('active');
                });
                document.getElementById('fontSize').value = template.size;
                document.getElementById('fontSizeValue').textContent = template.size;
                document.getElementById('strokeWidth').value = template.strokeWidth;
                document.getElementById('strokeWidthValue').textContent = template.strokeWidth;
                document.getElementById('shadowBlur').value = template.shadowBlur;
                document.getElementById('shadowBlurValue').textContent = template.shadowBlur;
                document.getElementById('shadowDistance').value = template.shadowDistance;
                document.getElementById('shadowDistanceValue').textContent = template.shadowDistance;
                document.getElementById('skewAngle').value = template.skew;
                document.getElementById('skewValue').textContent = template.skew;
                document.getElementById('customColor').value = template.color;
                document.getElementById('strokeColor').value = template.strokeColor;

                // Update color palette active states
                document.querySelectorAll('#colorPalette .color-swatch').forEach(swatch => {
                    swatch.classList.remove('active');
                    if (swatch.style.backgroundColor.toLowerCase() === template.color.toLowerCase()) {
                        swatch.classList.add('active');
                    }
                });
                document.querySelectorAll('#strokeColorPalette .color-swatch').forEach(swatch => {
                    swatch.classList.remove('active');
                    if (swatch.style.backgroundColor.toLowerCase() === template.strokeColor.toLowerCase()) {
                        swatch.classList.add('active');
                    }
                });

                updatePreviewText(); // Update canvas preview with new styles
                showNotification(`${templateName.replace(/([A-Z])/g, ' $1').trim().toUpperCase()} 폰트 스타일이 적용되었습니다!`, 'success');
            }
        }

        /**
         * Applies a glow effect by setting specific shadow and stroke properties.
         * @param {string} color - The base color for the glow (e.g., 'gold', 'blue').
         */
        function applyGlowEffect(color) {
            const glowColors = {
                gold: '#ffd700',
                blue: '#4169e1',
                red: '#ff4500',
                purple: '#9932cc'
            };

            selectedColor = glowColors[color] || '#ffffff';
            selectedStrokeColor = glowColors[color] || '#ffffff'; // Stroke color also contributes to glow
            currentStrokeWidth = 0; // No distinct stroke for pure glow
            currentShadowBlur = 25; // High blur for glow
            currentShadowDistance = 0; // No offset for glow

            // Update UI
            document.getElementById('strokeWidth').value = 0;
            document.getElementById('strokeWidthValue').textContent = 0;
            document.getElementById('shadowBlur').value = 25;
            document.getElementById('shadowBlurValue').textContent = 25;
            document.getElementById('shadowDistance').value = 0;
            document.getElementById('shadowDistanceValue').textContent = 0;
            document.getElementById('customColor').value = glowColors[color];
            document.getElementById('strokeColor').value = glowColors[color];

            // Update color palette active states
            document.querySelectorAll('#colorPalette .color-swatch').forEach(swatch => {
                swatch.classList.remove('active');
                if (swatch.style.backgroundColor.toLowerCase() === glowColors[color].toLowerCase()) {
                    swatch.classList.add('active');
                }
            });
            document.querySelectorAll('#strokeColorPalette .color-swatch').forEach(swatch => {
                swatch.classList.remove('active');
                if (swatch.style.backgroundColor.toLowerCase() === glowColors[color].toLowerCase()) {
                    swatch.classList.add('active');
                }
            });

            updatePreviewText();
            showNotification(`${color.toUpperCase()} 글로우 효과가 적용되었습니다!`, 'success');
        }

        /**
         * Generates a random Lost Ark themed text based on the specified type.
         * @param {string} type - The category of text (e.g., 'raid', 'tier', 'pvp', 'guide').
         */
        function generateLostArkText(type) {
            const textTemplates = {
                raid: [
                    '발탄 하드 원킬!', '비아키스 극한딜', '쿠크세이튼 완벽공략',
                    '카양겔 4관문 클리어', '아브렐슈드 헬모드', '일리아칸 노미스 도전'
                ],
                tier: [
                    '1590 달성!', '고급 헤어트 성공', '아이템 레벨 업!',
                    '1600+ 진입', '전설 무기 완성', '고대 악세 완성'
                ],
                pvp: [
                    'PVP 최강덱!', '투기장 승률 90%', '데스매치 1등',
                    'PVP 꿀팁 대공개', '격투 마스터의 비법', '투기장 천상계 도전'
                ],
                guide: [
                    '초보자 완벽가이드', '골드 버는 꿀팁', '각인 세팅 총정리',
                    '보석 세팅 가이드', '스킬트리 최적화', '어비스 던전 공략'
                ]
            };

            const templates = textTemplates[type] || textTemplates.guide;
            const randomText = templates[Math.floor(Math.random() * templates.length)];
            document.getElementById('thumbnailText').value = randomText;
            updatePreviewText(); // Update canvas preview
            showNotification(`로스트아크 ${type} 텍스트가 생성되었습니다!`, 'success');
        }

        /**
         * Loads a user-selected image as the canvas background.
         */
        function loadBackgroundImage() {
            const input = document.getElementById('backgroundImage');
            const file = input.files[0];
            
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        // Do NOT clear canvas.currentTemplate here. It will be drawn as an overlay.
                        currentLoadedBackgroundImage = img; // Store the actual Image object
                        
                        // Set initial image size to cover the canvas while maintaining aspect ratio
                        const imgAspectRatio = img.width / img.height;
                        const canvasAspectRatio = canvas.width / canvas.height;

                        if (imgAspectRatio > canvasAspectRatio) {
                            // Image is wider than canvas, fit height
                            currentBackgroundImageHeight = canvas.height;
                            currentBackgroundImageWidth = img.width * (canvas.height / img.height);
                        } else {
                            // Image is taller than canvas, fit width
                            currentBackgroundImageWidth = canvas.width;
                            currentBackgroundImageHeight = img.height * (canvas.width / img.width);
                        }
                        currentBackgroundImageX = (canvas.width - currentBackgroundImageWidth) / 2;
                        currentBackgroundImageY = (canvas.height - currentBackgroundImageHeight) / 2;

                        // Update sliders to reflect initial image position and size
                        document.getElementById('bgImageX').value = currentBackgroundImageX;
                        document.getElementById('bgImageY').value = currentBackgroundImageY;
                        document.getElementById('bgImageWidth').value = currentBackgroundImageWidth;
                        document.getElementById('bgImageHeight').value = currentBackgroundImageHeight;
                        document.getElementById('bgImageXValue').textContent = Math.round(currentBackgroundImageX);
                        document.getElementById('bgImageYValue').textContent = Math.round(currentBackgroundImageY);
                        document.getElementById('bgImageWidthValue').textContent = Math.round(currentBackgroundImageWidth);
                        document.getElementById('bgImageHeightValue').textContent = Math.round(currentBackgroundImageHeight);


                        redrawCanvas(); // Redraw with the new background image
                        saveCanvasState(); // Save state after loading image
                        showNotification('배경 이미지가 로드되었습니다!', 'success');
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            } else {
                showNotification('이미지 파일을 선택해주세요.', 'info');
            }
        }

        /**
         * Clears all content from the canvas and resets text objects.
         */
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            textObjects = []; // Remove all confirmed text objects
            selectedTextIndex = -1; // Deselect any text
            previewText = null; // Clear preview text
            canvas.currentTemplate = null; // Clear current template
            currentLoadedBackgroundImage = null; // Clear the loaded Image object
            backgroundOverlayColor = '#000000'; // Reset overlay color
            backgroundOverlayOpacity = 0; // Reset overlay opacity
            document.getElementById('backgroundOverlayColor').value = backgroundOverlayColor;
            document.getElementById('backgroundOverlayOpacity').value = 0;
            document.getElementById('backgroundOverlayOpacityValue').textContent = 0;
            
            // Reset background image position/size sliders to default canvas size
            currentBackgroundImageX = 0;
            currentBackgroundImageY = 0;
            currentBackgroundImageWidth = 1280;
            currentBackgroundImageHeight = 720;
            document.getElementById('bgImageX').value = currentBackgroundImageX;
            document.getElementById('bgImageY').value = currentBackgroundImageY;
            document.getElementById('bgImageWidth').value = currentBackgroundImageWidth;
            document.getElementById('bgImageHeight').value = currentBackgroundImageHeight;
            document.getElementById('bgImageXValue').textContent = currentBackgroundImageX;
            document.getElementById('bgImageYValue').textContent = currentBackgroundImageY;
            document.getElementById('bgImageWidthValue').textContent = currentBackgroundImageWidth;
            document.getElementById('bgImageHeightValue').textContent = currentBackgroundImageHeight;

            // Redraw default Lost Ark background
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(0.5, '#16213e');
            gradient.addColorStop(1, '#0f3460');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            saveCanvasState(); // Save state after clearing canvas
            showNotification('캔버스가 초기화되었습니다.', 'success');
        }

        /**
         * Downloads the current canvas content as a PNG image.
         */
        function downloadThumbnail() {
            // Temporarily hide preview text and selection border for a clean download
            const tempPreview = previewText;
            const tempSelectedTextIndex = selectedTextIndex;
            previewText = null;
            selectedTextIndex = -1; // Deselect any text

            redrawCanvas(); // Redraw without preview or selection border

            const link = document.createElement('a');
            link.download = `lostark-thumbnail-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png', 1.0); // Get canvas content as PNG data URL
            link.click(); // Trigger download

            // Restore preview text and selection
            previewText = tempPreview;
            selectedTextIndex = tempSelectedTextIndex;
            redrawCanvas(); // Redraw to bring back preview and selection if they were active
            
            showNotification('썸네일이 다운로드되었습니다! 🎬', 'success');
        }

        /**
         * Generates advanced YouTube video titles based on keywords, category, and emotion.
         */
        function generateAdvancedTitles() {
            const keyword = document.getElementById('titleKeyword').value.trim();
            const category = document.getElementById('titleCategory').value;
            const emotion = document.getElementById('emotionTone').value;
            
            if (!keyword) {
                showNotification('키워드를 입력해주세요.', 'error');
                return;
            }

            const emotionWords = {
                exciting: ['완전', '대박', '놀라운', '환상적인', '엄청난'],
                shocking: ['충격', '실화냐', '헉', '믿을 수 없는', '소름끼치는'],
                funny: ['개웃긴', '빵터지는', '폭소', '재미있는', '유쾌한'],
                informative: ['완벽한', '전문가의', '상세한', '꼼꼼한', '체계적인'],
                mysterious: ['비밀의', '숨겨진', '신비로운', '미스터리', '알려지지 않은']
            };

            const titleTemplates = {
                'how-to': [
                    `${emotionWords[emotion][0]} ${keyword} 가이드 | 초보자도 10분만에 마스터!`,
                    `${keyword} ${emotionWords[emotion][1]} 방법 🔥 전문가가 알려주는 비법`,
                    `${keyword} 완전정복! ${emotionWords[emotion][2]} 꿀팁 대공개`,
                    `처음하는 ${keyword}, 이 영상 하나면 ${emotionWords[emotion][3]}!`,
                    `${keyword} ${emotionWords[emotion][4]} 마스터 되기 | 단계별 완벽 가이드`
                ],
                'review': [
                    `${keyword} ${emotionWords[emotion][0]} 후기 | 장단점 솔직하게 다 말해드림`,
                    `${keyword} 리얼 사용기 🔥 ${emotionWords[emotion][1]} 구매 전 필수시청!`,
                    `${keyword} 이거 ${emotionWords[emotion][2]}? 팩트체크 해봤습니다`,
                    `${keyword} VS 경쟁제품 | ${emotionWords[emotion][3]} 비교분석`,
                    `${keyword} 한달 써본 ${emotionWords[emotion][4]} 진짜 후기`
                ],
                'gaming': [
                    `${keyword} ${emotionWords[emotion][0]} 게임플레이 | 고수의 비법 공개`,
                    `${keyword} ${emotionWords[emotion][1]} 순간들 모음 🎮 레전드 영상`,
                    `${keyword} 초보 탈출 가이드 | ${emotionWords[emotion][2]} 팁 모음집`,
                    `${keyword} ${emotionWords[emotion][3]} 하이라이트 | 환상적인 플레이`,
                    `${keyword} 숨겨진 꿀팁 | ${emotionWords[emotion][4]} 고급 전략`
                ],
                'vlog': [
                    `${emotionWords[emotion][0]} ${keyword} 브이로그 | 나의 일상 대공개!`,
                    `${keyword}와 함께하는 ${emotionWords[emotion][1]} 하루 ✨`,
                    `${keyword}에서 ${emotionWords[emotion][2]} 경험 | 절대 후회 안 함!`,
                    `나의 ${keyword} 라이프 | ${emotionWords[emotion][3]} 순간들`,
                    `${keyword} 도전기 | ${emotionWords[emotion][4]} 결과는?!`
                ],
                'music': [
                    `${emotionWords[emotion][0]} ${keyword} 커버 | 소름 돋는 라이브`,
                    `${keyword} ${emotionWords[emotion][1]} 리액션 | 듣자마자 눈물 펑펑 😭`,
                    `나만의 ${keyword} 플레이리스트 | ${emotionWords[emotion][2]} 감성 폭발`,
                    `${keyword} ${emotionWords[emotion][3]} 분석 | 숨겨진 의미는?`,
                    `${keyword} ${emotionWords[emotion][4]} 노래 추천 | 잠 못 드는 밤 필수곡`
                ],
                'comedy': [
                    `${emotionWords[emotion][0]} ${keyword} 몰래카메라 | 반응 실화냐?`,
                    `${keyword} ${emotionWords[emotion][1]} 순간들 | 웃다가 기절할 뻔 🤣`,
                    `${keyword} ${emotionWords[emotion][2]} 챌린지 | 역대급 웃음 보장!`,
                    `${emotionWords[emotion][3]} ${keyword} 개그 모음 | 스트레스 해소 직빵!`,
                    `${keyword} ${emotionWords[emotion][4]} 상황극 | 공감 100% ㅋㅋㅋ`
                ],
                'news': [
                    `속보! ${keyword} ${emotionWords[emotion][0]} 사건의 전말`,
                    `${keyword} ${emotionWords[emotion][1]} 분석 | 당신이 몰랐던 진실`,
                    `${keyword} ${emotionWords[emotion][2]} 이슈 | 전문가 긴급 진단`,
                    `${keyword} ${emotionWords[emotion][3]} 뉴스 브리핑 | 놓치지 마세요!`,
                    `${keyword} ${emotionWords[emotion][4]} 사건의 미스터리 | 과연 범인은?`
                ],
                'unboxing': [
                    `${emotionWords[emotion][0]} ${keyword} 언박싱 | 드디어 내 손에!`,
                    `${keyword} ${emotionWords[emotion][1]} 개봉기 | 기대 이상인데?`,
                    `${keyword} ${emotionWords[emotion][2]} 언박싱 리얼 후기 | 솔직히 말해서...`,
                    `${emotionWords[emotion][3]} ${keyword} 언박싱 | 이거 사도 될까?`,
                    `${emotionWords[emotion][4]} ${keyword} 언박싱 | 숨겨진 기능 발견?!`
                ],
                'challenge': [
                    `${emotionWords[emotion][0]} ${keyword} 챌린지 | 성공할 수 있을까?`,
                    `${keyword} ${emotionWords[emotion][1]} 챌린지 | 역대급 난이도!`,
                    `${keyword} ${emotionWords[emotion][2]} 챌린지 | 과연 결과는?`,
                    `${emotionWords[emotion][3]} ${keyword} 챌린지 | 당신도 할 수 있다!`,
                    `${emotionWords[emotion][4]} ${keyword} 챌린지 | 실패하면 벌칙! 😱`
                ]
            };

            const templates = titleTemplates[category] || titleTemplates['how-to'];
            const resultDiv = document.getElementById('titleResults');
            resultDiv.innerHTML = templates.map(title => 
                `<div style="margin: 12px 0; padding: 15px; background: rgba(255,255,255,0.08); border-radius: 10px; cursor: pointer; border-left: 4px solid #4ecdc4;" onclick="copyToClipboard('${title.replace(/'/g, "\\'")}')">
                    ${title} 
                    <small style="opacity: 0.7; float: right;"><i class="fas fa-copy"></i> 클릭하여 복사</small>
                </div>`
            ).join('');
            resultDiv.style.display = 'block';
            showNotification('고급 제목이 생성되었습니다!', 'success');
        }

        /**
         * Analyzes the performance of a given video title.
         */
        function analyzeAdvancedTitle() {
            const title = document.getElementById('titleAnalysis').value.trim();
            if (!title) {
                showNotification('분석할 제목을 입력해주세요.', 'error');
                return;
            }

            // Simple analysis based on length and keywords (can be expanded with LLM)
            let score = 0;
            let feedback = [];

            if (title.length >= 20 && title.length <= 70) {
                score += 30;
                feedback.push('✅ 제목 길이가 적절합니다 (20~70자 권장).');
            } else {
                feedback.push('⚠️ 제목 길이를 20~70자 사이로 조절하는 것이 좋습니다.');
            }

            if (title.includes('꿀팁') || title.includes('가이드') || title.includes('공략') || title.includes('방법')) {
                score += 20;
                feedback.push('✅ 정보성 키워드가 포함되어 검색 유입에 유리합니다.');
            } else {
                feedback.push('💡 정보성 또는 질문성 키워드를 추가하여 검색 노출을 늘려보세요.');
            }

            if (title.includes('🔥') || title.includes('⭐') || title.includes('🚨') || title.includes('😱') || title.includes('✨')) {
                score += 25;
                feedback.push('✅ 시선을 끄는 이모티콘이 잘 활용되었습니다.');
            } else {
                feedback.push('💡 시선을 사로잡는 이모티콘을 활용해 보세요.');
            }

            if (title.includes('최강') || title.includes('완벽') || title.includes('필수') || title.includes('대박')) {
                score += 25;
                feedback.push('✅ 클릭을 유도하는 강력한 단어가 포함되어 있습니다.');
            } else {
                feedback.push('💡 "최고", "필수", "대박" 등 클릭 유도 단어를 추가해 보세요.');
            }

            let overallFeedback;
            if (score >= 80) overallFeedback = '✨ 매우 우수! 클릭률이 높을 것으로 예상됩니다.';
            else if (score >= 60) overallFeedback = '👍 양호! 몇 가지 개선으로 더 좋아질 수 있습니다.';
            else overallFeedback = '⚠️ 개선 필요! 제목 전략을 재검토해 보세요.';

            const analysisResults = document.getElementById('analysisResults');
            analysisResults.innerHTML = `
                <div style="background: rgba(78, 205, 196, 0.1); padding: 20px; border-radius: 15px; margin-bottom: 20px;">
                    <strong>📊 제목 분석 결과: ${overallFeedback}</strong><br><br>
                    <strong>점수: ${score}/100</strong>
                </div>
                <strong>세부 피드백:</strong>
                <ul style="list-style: none; padding: 0; margin-top: 10px;">
                    ${feedback.map(item => `<li style="margin-bottom: 8px;">${item}</li>`).join('')}
                </ul>
            `;
            analysisResults.style.display = 'block';
            showNotification('제목 분석이 완료되었습니다!', 'success');
        }

        /**
         * Generates smart tags based on the video topic and target language.
         */
        function generateSmartTags() {
            const topic = document.getElementById('tagTopic').value.trim();
            const language = document.getElementById('tagLanguage').value;
            
            if (!topic) {
                showNotification('영상 주제를 입력해주세요.', 'error');
                return;
            }

            const koreanTags = [
                `${topic}`, `${topic}추천`, `${topic}리뷰`, `${topic}방법`, `${topic}팁`,
                `${topic}가이드`, `${topic}튜토리얼`, `${topic}초보`, `${topic}전문가`,
                `${topic}꿀팁`, `${topic}비법`, `${topic}노하우`, `${topic}완전정복`,
                '유튜브', '구독', '좋아요', '댓글', '알림설정', '한국', 'Korean'
            ];

            const englishTags = [
                `${topic}`, `${topic} tutorial`, `${topic} guide`, `${topic} tips`,
                `${topic} review`, `${topic} how to`, `${topic} beginners`,
                `${topic} advanced`, `${topic} tricks`, `${topic} secrets`,
                'youtube', 'subscribe', 'like', 'comment', 'tutorial', 'guide'
            ];

            let allTags = [];
            if (language === 'ko') allTags = koreanTags;
            else if (language === 'en') allTags = englishTags;
            else allTags = [...koreanTags, ...englishTags];

            const tagContainer = document.getElementById('tagResults');
            tagContainer.innerHTML = allTags.slice(0, 20).map(tag => 
                `<span class="tag" onclick="copyToClipboard('${tag}')">${tag}</span>`
            ).join('');
            showNotification('스마트 태그가 생성되었습니다!', 'success');
        }

        /**
         * Generates trending hashtags based on the selected category.
         */
        function generateTrendingHashtags() {
            const category = document.getElementById('hashtagCategory').value;
            
            const hashtags = {
                general: ['#유튜브', '#구독자', '#좋아요', '#일상', '#브이로그', '#꿀팁', '#정보', '#추천', '#Shorts'],
                gaming: ['#게임', '#게이머', '#스트리머', '#e스포츠', '#모바일게임', '#PC게임', '#게임리뷰', '#게임추천', '#로스트아크', '#발로란트', '#리그오브레전드'],
                beauty: ['#뷰티', '#메이크업', '#화장품', '#스킨케어', '#코스메틱', '#뷰티팁', '#메이크업튜토리얼', '#뷰티제품'],
                food: ['#요리', '#레시피', '#맛집', '#먹방', '#쿠킹', '#음식', '#홈쿡', '#디저트'],
                tech: ['#기술', '#IT', '#스마트폰', '#리뷰', '#언박싱', '#테크', '#가젯', '#디지털', '#AI', '#ChatGPT'],
                lifestyle: ['#라이프스타일', '#일상', '#브이로그', '#취미', '#여행', '#인테리어', '#패션', '#건강']
            };

            const selectedHashtags = hashtags[category] || hashtags.general;
            const container = document.getElementById('hashtagResults');
            container.innerHTML = selectedHashtags.map(tag => 
                `<span class="tag" onclick="copyToClipboard('${tag}')">${tag}</span>`
            ).join('');
            showNotification('트렌딩 해시태그가 생성되었습니다!', 'success');
        }

        /**
         * Adds a new video upload schedule to the calendar.
         */
        function addAdvancedSchedule() {
            const title = document.getElementById('scheduleTitle').value.trim();
            const date = document.getElementById('scheduleDate').value;
            const category = document.getElementById('scheduleCategory').value;
            const priority = document.getElementById('schedulePriority').value;
            const notes = document.getElementById('scheduleNotes').value.trim();

            if (!title || !date) {
                showNotification('제목과 날짜를 모두 입력해주세요.', 'error');
                return;
            }

            const schedule = {
                id: Date.now(), // Unique ID for the schedule item
                title,
                date: new Date(date),
                category,
                priority,
                notes
            };

            schedules.push(schedule);
            schedules.sort((a, b) => a.date - b.date); // Sort by date
            updateAdvancedScheduleList(); // Update UI list

            // Clear input fields
            document.getElementById('scheduleTitle').value = '';
            document.getElementById('scheduleDate').value = '';
            document.getElementById('scheduleNotes').value = '';
            showNotification('스케줄이 성공적으로 추가되었습니다!', 'success');
        }

        /**
         * Updates the display list of scheduled video uploads.
         */
        function updateAdvancedScheduleList() {
            const listContainer = document.getElementById('scheduleList');
            listContainer.innerHTML = schedules.map(schedule => {
                const priorityIcon = {
                    high: '🔴',
                    medium: '🟡',
                    low: '🟢'
                };
                
                return `
                    <div class="schedule-item">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                            <div style="flex: 1;">
                                <strong>${schedule.title}</strong> ${priorityIcon[schedule.priority]}<br>
                                <small style="color: #4ecdc4;">${schedule.date.toLocaleString('ko-KR')} | ${schedule.category}</small>
                                ${schedule.notes ? `<div style="margin-top: 8px; opacity: 0.8; font-size: 13px;">${schedule.notes}</div>` : ''}
                            </div>
                            <button style="background: #ff6b6b; border: none; color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer;" onclick="removeSchedule(${schedule.id})">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('') || '<p style="opacity: 0.7; text-align: center;">예정된 업로드가 없습니다.</p>';
        }

        /**
         * Removes a schedule item from the list.
         * @param {number} id - The unique ID of the schedule item to remove.
         */
        function removeSchedule(id) {
            schedules = schedules.filter(s => s.id !== id);
            updateAdvancedScheduleList();
            showNotification('스케줄이 삭제되었습니다.', 'success');
        }

        /**
         * Exports the current schedule list as a CSV file.
         */
        function exportSchedule() {
            if (schedules.length === 0) {
                showNotification('저장할 스케줄이 없습니다.', 'info');
                return;
            }
            
            const csv = 'Title,Date,Category,Priority,Notes\n' + 
                        schedules.map(s => `"${s.title}","${s.date.toLocaleString()}","${s.category}","${s.priority}","${s.notes}"`).join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'youtube-schedule.csv';
            link.click();
            showNotification('스케줄이 CSV 파일로 내보내졌습니다!', 'success');
        }

        /**
         * Predicts video views based on channel metrics and upload time/length.
         */
        function predictAdvancedViews() {
            const avgViews = parseInt(document.getElementById('avgViews').value);
            const subscribers = parseInt(document.getElementById('subscribers').value);
            const videoLength = parseInt(document.getElementById('videoLength').value);
            const uploadTime = document.getElementById('uploadTime').value;

            if (isNaN(avgViews) || isNaN(subscribers) || isNaN(videoLength) || avgViews < 0 || subscribers < 0 || videoLength <= 0) {
                showNotification('모든 필드에 유효한 숫자를 입력해주세요.', 'error');
                return;
            }

            const engagementRate = (subscribers > 0) ? (avgViews / subscribers) * 100 : 0; // Avoid division by zero
            
            // Time and length modifiers (example values)
            const timeModifiers = {
                morning: 0.8,
                afternoon: 0.9,
                evening: 1.2, // Peak time
                night: 0.7
            };
            
            const lengthModifier = videoLength <= 5 ? 1.1 : // Shorter videos might get more initial views
                                   videoLength <= 10 ? 1.0 :
                                   videoLength <= 20 ? 0.9 : // Longer videos might have lower initial reach
                                   0.8;
            
            const baseModifier = timeModifiers[uploadTime] * lengthModifier;
            const predictedMin = Math.round(avgViews * 0.6 * baseModifier);
            const predictedMax = Math.round(avgViews * 1.4 * baseModifier);
            const predictedAvg = Math.round(avgViews * baseModifier);

            let channelStatus;
            if (engagementRate > 15) channelStatus = '🔥 매우 높은 참여율 - 바이럴 가능성 높음';
            else if (engagementRate > 8) channelStatus = '✅ 높은 참여율 - 건강한 채널';
            else if (engagementRate > 4) channelStatus = '👍 양호한 참여율 - 꾸준한 성장';
            else if (engagementRate > 2) channelStatus = '⚠️ 보통 참여율 - 콘텐츠 개선 필요';
            else channelStatus = '📉 낮은 참여율 - 전략 재검토 필요';

            const resultDiv = document.getElementById('viewPrediction');
            resultDiv.innerHTML = `
                <div style="background: rgba(78, 205, 196, 0.1); padding: 20px; border-radius: 15px; margin-bottom: 20px;">
                    <strong>🎯 AI 예측 결과</strong><br><br>
                    <div style="font-size: 1.1em; margin-bottom: 15px;">
                        <strong>예상 조회수:</strong> ${predictedMin.toLocaleString()} ~ ${predictedMax.toLocaleString()}<br>
                        <strong>평균 예측:</strong> ${predictedAvg.toLocaleString()}
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 15px; border-radius: 10px;">
                        <strong>참여율 분석</strong><br>
                        ${engagementRate.toFixed(1)}%
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 15px; border-radius: 10px;">
                        <strong>채널 건강도</strong><br>
                        ${channelStatus}
                    </div>
                </div>
                
                <div style="background: rgba(255, 107, 107, 0.1); padding: 15px; border-radius: 10px;">
                    <strong>🚀 성장 전략 제안</strong><br>
                    ${engagementRate < 5 ? 
                        '• 썸네일과 제목 최적화에 집중<br>• 콘텐츠 품질 향상 필요<br>• 시청자와의 소통 강화' :
                        '• 현재 전략 유지<br>• 업로드 주기 일관성 유지<br>• 새로운 포맷 실험'
                    }
                </div>
            `;
            resultDiv.style.display = 'block';
            showNotification('조회수 예측이 완료되었습니다!', 'success');
        }

        /**
         * Placeholder for channel growth analysis. In a real application, this would integrate with YouTube Analytics API.
         */
        function analyzeChannelGrowth() {
            showNotification('채널 성장 분석 기능이 실행되었습니다. 실제 환경에서는 유튜브 API 연동으로 더 정확한 데이터를 제공할 수 있습니다.', 'info');
        }

        /**
         * Researches advanced keywords based on a base keyword and desired competition level.
         */
        function researchAdvancedKeywords() {
            const baseKeyword = document.getElementById('baseKeyword').value.trim();
            const competition = document.getElementById('competitionLevel').value;
            
            if (!baseKeyword) {
                showNotification('기본 키워드를 입력해주세요.', 'error');
                return;
            }

            const competitionKeywords = {
                low: ['초보', '입문', '처음', '기초', '간단한', '쉬운'],
                medium: ['방법', '가이드', '팁', '노하우', '비법', '완전'],
                high: ['최고', '베스트', '인기', '트렌드', '핫한', '대박']
            };

            const selectedCompetition = competitionKeywords[competition];
            const relatedKeywords = [
                ...selectedCompetition.map(word => `${word} ${baseKeyword}`),
                ...selectedCompetition.map(word => `${baseKeyword} ${word}`),
                `${baseKeyword} 2024`, `${baseKeyword} 추천`, `${baseKeyword} 리뷰`,
                `${baseKeyword} 비교`, `${baseKeyword} 순위`, `${baseKeyword} 정보`
            ];

            const resultDiv = document.getElementById('keywordResults');
            resultDiv.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <strong>🔍 '${baseKeyword}' 관련 ${competition === 'low' ? '틈새' : competition === 'medium' ? '균형잡힌' : '경쟁적인'} 키워드</strong>
                </div>
                
                ${relatedKeywords.map((keyword, index) => 
                    `<div style="margin: 8px 0; padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; cursor: pointer; border-left: 3px solid ${index < 6 ? '#4ecdc4' : index < 12 ? '#45b7d1' : '#96ceb4'};" onclick="copyToClipboard('${keyword}')">
                        <span style="font-weight: 500;">${keyword}</span>
                        <span style="float: right; opacity: 0.7; font-size: 12px;">
                            ${index < 6 ? '🟢 쉬움' : index < 12 ? '🟡 보통' : '🔴 어려움'} 
                            <i class="fas fa-copy"></i>
                        </span>
                    </div>`
                ).join('')}
            `;
            resultDiv.style.display = 'block';
            showNotification('고급 키워드 분석이 완료되었습니다!', 'success');
        }

        /**
         * Analyzes and displays real-time trending topics based on category.
         */
        function analyzeTrends() {
            const category = document.getElementById('trendCategory').value;
            
            const trendData = {
                all: [
                    { keyword: 'AI 인공지능', trend: '상승', volume: '높음' },
                    { keyword: '메타버스', trend: '안정', volume: '중간' },
                    { keyword: '비트코인', trend: '하락', volume: '높음' },
                    { keyword: '넷플릭스 추천', trend: '상승', volume: '중간' },
                    { keyword: '홈트레이닝', trend: '상승', volume: '높음' }
                ],
                gaming: [
                    { keyword: '로스트아크', trend: '안정', volume: '높음' },
                    { keyword: '발로란트', trend: '상승', volume: '높음' },
                    { keyword: '리그오브레전드', trend: '안정', volume: '매우높음' },
                    { keyword: '원신', trend: '하락', volume: '중간' },
                    { keyword: '피파온라인4', trend: '상승', volume: '중간' }
                ],
                entertainment: [
                    { keyword: 'K-POP 리액션', trend: '상승', volume: '높음' },
                    { keyword: '웹툰 리뷰', trend: '상승', volume: '중간' },
                    { keyword: '예능 다시보기', trend: '안정', volume: '높음' },
                    { keyword: 'ASMR', trend: '안정', volume: '높음' },
                    { keyword: '브이로그', trend: '상승', volume: '매우높음' }
                ],
                tech: [
                    { keyword: '아이폰15 리뷰', trend: '하락', volume: '중간' },
                    { keyword: '갤럭시S24', trend: '상승', volume: '높음' },
                    { keyword: 'ChatGPT 활용법', trend: '상승', volume: '매우높음' },
                    { keyword: '전기차 비교', trend: '상승', volume: '중간' },
                    { keyword: '스마트홈', trend: '상승', volume: '중간' }
                ],
                lifestyle: [
                    { keyword: '미니멀 라이프', trend: '안정', volume: '중간' },
                    { keyword: '제로 웨이스트', trend: '상승', volume: '낮음' },
                    { keyword: '플랜테리어', trend: '상승', volume: '중간' },
                    { keyword: '워라밸', trend: '안정', volume: '높음' },
                    { keyword: '갓생 살기', trend: '상승', volume: '높음' }
                ],
                news: [
                    { keyword: '총선 결과', trend: '하락', volume: '매우높음' },
                    { keyword: '경제 전망', trend: '상승', volume: '높음' },
                    { keyword: '기후 변화', trend: '안정', volume: '높음' },
                    { keyword: '부동산 정책', trend: '상승', volume: '중간' },
                    { keyword: '세계 뉴스', trend: '안정', volume: '높음' }
                ]
            };

            const trends = trendData[category] || trendData.all;
            const container = document.getElementById('trendResults');
            
            container.innerHTML = trends.map(trend => {
                const trendIcon = trend.trend === '상승' ? '📈' : trend.trend === '하락' ? '📉' : '📊';
                const volumeColor = trend.volume === '매우높음' ? '#ff6b6b' : 
                                       trend.volume === '높음' ? '#4ecdc4' : 
                                       trend.volume === '중간' ? '#feca57' : '#96ceb4';
                
                return `
                    <div class="trend-item" onclick="copyToClipboard('${trend.keyword}')">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${trend.keyword}</strong> ${trendIcon}<br>
                                <small style="color: ${volumeColor};">검색량: ${trend.volume}</small>
                            </div>
                            <div style="text-align: right;">
                                <small style="opacity: 0.7;"><i class="fas fa-copy"></i> 복사</small>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            showNotification('실시간 트렌드 분석이 완료되었습니다!', 'success');
        }

        /**
         * Generates predefined comment templates based on type and tone.
         */
        function generateCommentTemplates() {
            const type = document.getElementById('commentType').value;
            const tone = document.getElementById('commentTone').value;
            
            const templates = {
                thanks: {
                    friendly: [
                        "시청해 주셔서 정말 감사합니다! 😊 좋은 하루 보내세요!",
                        "와! 이렇게 좋은 댓글 남겨주셔서 감동이에요 ❤️",
                        "구독자님 덕분에 힘이 나네요! 고맙습니다 🙏",
                        "따뜻한 댓글 정말 감사드려요! 더 좋은 영상으로 보답하겠습니다 ✨"
                    ],
                    professional: [
                        "시청해 주셔서 감사합니다. 지속적으로 양질의 콘텐츠로 찾아뵙겠습니다.",
                        "소중한 피드백 감사드립니다. 앞으로도 많은 관심 부탁드립니다.",
                        "구독과 좋아요에 진심으로 감사드립니다.",
                        "귀중한 시간을 내어 시청해 주셔서 감사합니다."
                    ],
                    enthusiastic: [
                        "대박! 정말 감사드립니다! 여러분 최고예요! 🎉",
                        "와우! 이런 뜨거운 반응이라니! 사랑합니다! 😍",
                        "정말 감동의 쓰나미! 여러분의 성원에 보답할게요! 🚀",
                        "미쳤다! 너무 감사해서 몸 둘 바를 모르겠어요! 💖"
                    ]
                },
                question: {
                    friendly: [
                        "좋은 질문이네요! 🤔 [답변] 이에 대해 어떻게 생각하시나요?",
                        "오! 그 부분 궁금하셨군요 😄 [답변] 도움이 되셨길 바라요!",
                        "질문 감사해요! [답변] 추가로 궁금한 게 있으시면 언제든 물어보세요 💪",
                        "와! 핵심을 콕 집어주셨네요 👍 [답변] 이해되셨나요?"
                    ],
                    professional: [
                        "질문해 주셔서 감사합니다. [답변] 추가 문의사항이 있으시면 언제든 연락 주세요.",
                        "좋은 지적입니다. [답변] 이 설명이 도움이 되기를 바랍니다.",
                        "해당 내용에 대해 설명드리겠습니다. [답변]",
                        "문의해 주신 사항에 대해 답변드립니다. [답변]"
                    ],
                    enthusiastic: [
                        "최고의 질문! 바로 답변 드릴게요! [답변] 어떠세요?! 🔥",
                        "이 질문 기다렸어요! [답변] 궁금증 해결되셨길 바라요! ✨",
                        "와우! 날카로운 질문! [답변] 속 시원하게 알려드립니다! 🚀",
                        "이런 질문 너무 좋아요! [답변] 더 궁금한 건 없으신가요? 😉"
                    ]
                },
                engagement: {
                    friendly: [
                        "여러분은 어떻게 생각하시나요? 댓글로 의견 들려주세요! 💬",
                        "구독자님들의 경험담도 궁금해요! 공유해 주실래요? 🤗",
                        "다음에는 어떤 주제로 영상 만들까요? 추천해 주세요! 🎬",
                        "이 영상이 도움됐다면 좋아요와 구독 부탁드려요! 😍"
                    ],
                    casual: [
                        "여러분 생각은 어떤가요? 댓글 ㄱㄱ 👇",
                        "이거 어떻게 생각함? 솔직히 말해줘 ㅋㅋ",
                        "다음 영상 주제 추천받아요! 뭐가 좋을까?",
                        "구독 안 하면 손가락 아파요... 농담이에요 ㅎㅎ"
                    ],
                    enthusiastic: [
                        "여러분 의견이 정말 중요해요! 불꽃 댓글 부탁드립니다! 🔥",
                        "여러분의 참여가 저에게 큰 힘이 됩니다! 댓글로 소통해요! 💖",
                        "다음 영상 아이디어 팍팍 던져주세요! 제가 다 만들어 드립니다! 💡",
                        "좋아요와 구독은 사랑입니다! 잊지 마세요! 😉"
                    ]
                },
                collaboration: {
                    professional: [
                        "협업 제안 감사드립니다. 상세 내용은 [이메일 주소]로 보내주시면 검토 후 연락드리겠습니다.",
                        "귀사와의 협업에 관심이 있습니다. 제안서를 보내주시면 감사하겠습니다.",
                        "긍정적으로 검토하겠습니다. 연락처를 남겨주시면 담당자가 연락드릴 예정입니다."
                    ],
                    friendly: [
                        "협업 제안이라니! 너무 좋아요! 자세한 내용은 메일 주세요! 😊",
                        "같이 재밌는 거 만들어 봐요! 연락 기다릴게요! 🤝"
                    ]
                },
                announcement: {
                    professional: [
                        "중요 공지사항입니다. [내용]에 대한 업데이트가 있으니 확인 부탁드립니다.",
                        "긴급 안내 드립니다. [내용] 관련하여 변경 사항이 발생했습니다.",
                        "향후 채널 운영에 대한 안내 말씀 드립니다. [내용]"
                    ],
                    friendly: [
                        "여러분께 알려드릴 소식이 있어요! 📢 [내용] 꼭 확인해 주세요!",
                        "짜잔! 새로운 공지입니다! ✨ [내용] 놓치지 마세요!",
                        "급하게 알려드려요! 🚨 [내용] 다들 아셨으면 좋겠어요!"
                    ]
                }
            };

            const selectedTemplates = templates[type]?.[tone] || templates.thanks.friendly;
            const resultDiv = document.getElementById('commentResults');
            
            resultDiv.innerHTML = `
                <strong>💬 ${type} - ${tone} 스타일 템플릿</strong><br><br>
                ${selectedTemplates.map(template => 
                    `<div style="margin: 10px 0; padding: 15px; background: rgba(255,255,255,0.08); border-radius: 10px; cursor: pointer; border-left: 4px solid #4ecdc4;" onclick="copyToClipboard('${template.replace(/'/g, "\\'")}')">
                        ${template}
                        <small style="opacity: 0.7; float: right;"><i class="fas fa-copy"></i> 복사</small>
                    </div>`
                ).join('')}
            `;
            resultDiv.style.display = 'block';
            showNotification('댓글 템플릿이 생성되었습니다!', 'success');
        }

        /**
         * Generates a community post based on the topic and type.
         */
        function generateCommunityPost() {
            const topic = document.getElementById('postTopic').value.trim();
            const type = document.getElementById('postType').value;
            
            if (!topic) {
                showNotification('포스트 주제를 입력해주세요.', 'error');
                return;
            }

            const postTemplates = {
                poll: [
                    `${topic}에 대한 여러분의 의견을 들려주세요! 🗳️\n\n어떤 선택이 더 좋을까요?\nA) [옵션1]\nB) [옵션2]\n\n댓글로 투표해 주세요! 📊`,
                    `🤔 ${topic} 관련해서 궁금한데요!\n\n여러분이라면 어떻게 하실 건가요?\n투표로 알려주세요!\n\n좋아요 = 찬성 ❤️\n웃음 = 반대 😂`
                ],
                question: [
                    `${topic}에 대해 질문이 있어요! 🙋‍♂️\n\n여러분의 경험이나 노하우를 공유해 주시면 정말 감사하겠습니다!\n\n댓글로 꿀팁 남겨주세요 💡`,
                    `구독자님들에게 물어보고 싶은 게 있어요!\n\n${topic} 관련해서 어떻게 생각하시나요?\n\n솔직한 의견 댓글로 들려주세요! 😊`
                ],
                announcement: [
                    `📢 중요한 공지사항입니다!\n\n${topic} 관련하여 업데이트가 있어요!\n\n자세한 내용은 곧 업로드될 영상에서 확인하실 수 있습니다 🎬\n\n알림 설정 잊지 마세요! 🔔`,
                    `🎉 구독자님들께 알려드립니다!\n\n${topic}에 대한 새로운 소식이 있어요!\n\n기대해 주세요! ✨`
                ],
                behind: [
                    `🎬 비하인드 스토리 공개!\n\n${topic} 영상 촬영하면서 있었던 재미있는 일들을 공유해요!\n\n[비하인드 내용 추가]\n\n여러분도 궁금한 비하인드가 있다면 댓글로 물어보세요! 🤗`,
                    `📸 촬영 현장 공개!\n\n${topic} 관련 콘텐츠 만들면서의 솔직한 이야기들!\n\n실제로는 이랬답니다... ㅋㅋ\n\n다음 비하인드도 기대해 주세요! 💪`
                ],
                teaser: [
                    `🔥 예고편 공개!\n\n다음 영상은 ${topic}에 대한 내용입니다!\n\n정말 대박적인 내용을 준비했어요!\n언제 업로드될지 맞춰보세요! 🎯\n\n힌트: 이번 주 안에! ✨`,
                    `⚡ 스포일러 주의!\n\n${topic} 관련해서 완전 신박한 영상을 준비 중이에요!\n\n여러분이 상상하는 것보다 훨씬 재미있을 거예요!\n\n기대되시나요? 댓글로 예상해 보세요! 🚀`
                ]
            };

            const templates = postTemplates[type];
            const resultDiv = document.getElementById('postResults');
            
            resultDiv.innerHTML = `
                <strong>📝 ${type} 타입 커뮤니티 포스트</strong><br><br>
                ${templates.map(template => 
                    `<div style="margin: 15px 0; padding: 20px; background: rgba(255,255,255,0.08); border-radius: 12px; cursor: pointer; border-left: 4px solid #ff6b6b; white-space: pre-line;" onclick="copyToClipboard('${template.replace(/'/g, "\\'")}')">
                        ${template}
                        <div style="margin-top: 15px; text-align: right;">
                            <small style="opacity: 0.7;"><i class="fas fa-copy"></i> 클릭하여 복사</small>
                        </div>
                    </div>`
                ).join('')}
            `;
            resultDiv.style.display = 'block';
            showNotification('커뮤니티 포스트가 생성되었습니다!', 'success');
        }

        /**
         * Adds a new subtitle entry to the list.
         */
        function addSubtitle() {
            const startTime = parseFloat(document.getElementById('startTime').value) || 0;
            const endTime = parseFloat(document.getElementById('endTime').value) || 5;
            const text = document.getElementById('subtitleTextInput').value.trim();
            const font = document.getElementById('subtitleFont').value;
            const fontSize = document.getElementById('subtitleFontSize').value;
            const position = document.getElementById('subtitlePosition').value;
            const textColor = document.getElementById('subtitleTextColor').value;
            const bgColor = document.getElementById('subtitleBgColor').value;
            const bgOpacity = document.getElementById('subtitleBgOpacity').value;
            
            if (!text) {
                showNotification('자막 텍스트를 입력해주세요.', 'error');
                return;
            }
            
            if (endTime <= startTime) {
                showNotification('종료 시간은 시작 시간보다 커야 합니다.', 'error');
                return;
            }
            
            const subtitle = {
                id: Date.now(),
                startTime,
                endTime,
                text,
                font,
                fontSize,
                position,
                textColor,
                bgColor,
                bgOpacity
            };
            
            subtitles.push(subtitle);
            subtitles.sort((a, b) => a.startTime - b.startTime); // Sort by start time
            updateSubtitlePreview(); // Update preview list
            
            // Reset input fields for next entry
            document.getElementById('startTime').value = endTime;
            document.getElementById('endTime').value = endTime + 5;
            document.getElementById('subtitleTextInput').value = '';
            showNotification('자막이 추가되었습니다!', 'success');
        }

        /**
         * Loads subtitles from an uploaded SRT file.
         */
        function loadSrtFile() {
            const input = document.getElementById('srtUpload');
            const file = input.files[0];

            if (!file) {
                showNotification('SRT 파일을 선택해주세요.', 'info');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const srtContent = e.target.result;
                const srtEntries = srtContent.split(/\r?\n\r?\n/).filter(entry => entry.trim() !== '');

                subtitles = []; // Clear existing subtitles
                const currentFont = document.getElementById('subtitleFont').value;
                const currentFontSize = document.getElementById('subtitleFontSize').value;
                const currentPosition = document.getElementById('subtitlePosition').value;
                const currentTextColor = document.getElementById('subtitleTextColor').value;
                const currentBgColor = document.getElementById('subtitleBgColor').value;
                const currentBgOpacity = document.getElementById('subtitleBgOpacity').value;

                srtEntries.forEach(entry => {
                    const lines = entry.split(/\r?\n/);
                    if (lines.length >= 2) {
                        const index = parseInt(lines[0]);
                        const timeString = lines[1];
                        const text = lines.slice(2).join('\n'); // Join remaining lines as text

                        const timeMatch = timeString.match(/(\d{2}):(\d{2}):(\d{2}),(\d{3}) --> (\d{2}):(\d{2}):(\d{2}),(\d{3})/);
                        if (timeMatch) {
                            const startH = parseInt(timeMatch[1]);
                            const startM = parseInt(timeMatch[2]);
                            const startS = parseInt(timeMatch[3]);
                            const startMs = parseInt(timeMatch[4]);
                            const endH = parseInt(timeMatch[5]);
                            const endM = parseInt(timeMatch[6]);
                            const endS = parseInt(timeMatch[7]);
                            const endMs = parseInt(timeMatch[8]);

                            const startTime = (startH * 3600) + (startM * 60) + startS + (startMs / 1000);
                            const endTime = (endH * 3600) + (endM * 60) + endS + (endMs / 1000);

                            subtitles.push({
                                id: Date.now() + index, // Unique ID
                                startTime,
                                endTime,
                                text,
                                font: currentFont, // Apply current style settings from UI
                                fontSize: currentFontSize,
                                position: currentPosition,
                                textColor: currentTextColor,
                                bgColor: currentBgColor,
                                bgOpacity: currentBgOpacity
                            });
                        }
                    }
                });
                subtitles.sort((a, b) => a.startTime - b.startTime);
                updateSubtitlePreview();
                showNotification('SRT 파일이 성공적으로 로드되었습니다!', 'success');
            };
            reader.readAsText(file);
        }

        /**
         * Updates the display list of subtitles in the preview area.
         */
        function updateSubtitlePreview() {
            const container = document.getElementById('subtitleList');
            container.innerHTML = subtitles.map(subtitle => `
                <div class="subtitle-item" style="
                    font-family: '${subtitle.font}', sans-serif;
                    font-size: ${subtitle.fontSize}px;
                    color: ${subtitle.textColor};
                    background-color: rgba(${hexToRgb(subtitle.bgColor).r}, ${hexToRgb(subtitle.bgColor).g}, ${hexToRgb(subtitle.bgColor).b}, ${subtitle.bgOpacity / 100});
                    text-align: center; /* Subtitles are typically centered */
                    padding: 10px;
                    border-radius: 8px;
                    margin-bottom: 10px;
                    position: relative;
                ">
                    <div style="font-family: 'Roboto', monospace;" class="subtitle-time">${formatTime(subtitle.startTime)} --> ${formatTime(subtitle.endTime)}</div>
                    <div class="subtitle-text">${subtitle.text}</div>
                    <div style="font-size: 0.7em; opacity: 0.8; margin-top: 5px;">
                        (${subtitle.font}, ${subtitle.fontSize}px, ${subtitle.position})
                    </div>
                    <button style="position: absolute; top: 5px; right: 5px; background: #ff6b6b; border: none; color: white; padding: 5px 10px; border-radius: 5px; cursor: pointer;" onclick="removeSubtitle(${subtitle.id})">삭제</button>
                </div>
            `).join('') || '<p style="opacity: 0.7; text-align: center;">자막이 없습니다.</p>';
        }

        /** Converts hex color to RGB object. */
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return { r, g, b };
        }

        /**
         * Formats seconds into HH:MM:SS,ms format for SRT.
         * @param {number} seconds - The time in seconds.
         * @returns {string} Formatted time string.
         */
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            const milliseconds = Math.round((seconds - Math.floor(seconds)) * 1000);
            
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${milliseconds.toString().padStart(3, '0')}`;
        }

        /**
         * Removes a subtitle entry from the list.
         * @param {number} id - The unique ID of the subtitle to remove.
         */
        function removeSubtitle(id) {
            subtitles = subtitles.filter(s => s.id !== id);
            updateSubtitlePreview();
            showNotification('자막이 삭제되었습니다.', 'success');
        }

        /**
         * Exports subtitles in SRT or VTT format.
         * @param {string} format - The desired export format ('srt' or 'vtt').
         */
        function exportSubtitles(format) {
            if (subtitles.length === 0) {
                showNotification('저장할 자막이 없습니다.', 'info');
                return;
            }
            
            let content = '';
            
            if (format === 'srt') {
                content = subtitles.map((subtitle, index) => 
                    `${index + 1}\n${formatTime(subtitle.startTime)} --> ${formatTime(subtitle.endTime)}\n${subtitle.text}\n`
                ).join('\n');
            } else if (format === 'vtt') {
                content = 'WEBVTT\n\n' + subtitles.map(subtitle => 
                    `${formatTime(subtitle.startTime).replace(',', '.')} --> ${formatTime(subtitle.endTime).replace(',', '.')}\n${subtitle.text}\n`
                ).join('\n');
            }
            
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `subtitles.${format}`;
            link.click();
            showNotification(`자막이 ${format.toUpperCase()} 파일로 내보내졌습니다!`, 'success');
        }

        /**
         * Copies text to the clipboard.
         * @param {string} text - The text to copy.
         */
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showNotification('클립보드에 복사되었습니다! 📋', 'success');
            }).catch(() => {
                // Fallback method for older browsers or restricted environments
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showNotification('클립보드에 복사되었습니다! 📋', 'success');
            });
        }

        /**
         * Displays a custom notification message.
         * @param {string} message - The message to display.
         * @param {string} type - The type of notification ('success', 'error', 'info').
         */
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 30px;
                right: 30px;
                background: ${type === 'success' ? 'linear-gradient(45deg, #4ecdc4, #44a08d)' : 
                                type === 'error' ? 'linear-gradient(45deg, #ff6b6b, #ee5a52)' : 
                                'linear-gradient(45deg, #667eea, #764ba2)'};
                color: white;
                padding: 15px 25px;
                border-radius: 12px;
                z-index: 10000;
                font-weight: 500;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                animation: slideInNotification 0.5s ease-out forwards;
                cursor: pointer;
            `;
            
            document.body.appendChild(notification);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOutNotification 0.5s ease-in forwards';
                setTimeout(() => notification.remove(), 500);
            }, 3000);
            
            // Remove immediately on click
            notification.onclick = () => {
                notification.style.animation = 'slideOutNotification 0.3s ease-in forwards';
                setTimeout(() => notification.remove(), 300);
            };
        }
    </script>
</body>
</html>
�